#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wconversion"

/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000048 generated on 2016-11-23 22:55:01.752595
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( std::isnan(fy) ) {
        IKFAST_ASSERT(!std::isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( std::isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    (void)epsilon;
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !std::isnan(fy) && !std::isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }

    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61;
x0=IKcos(j[5]);
x1=IKsin(j[1]);
x2=IKcos(j[0]);
x3=IKcos(j[3]);
x4=(x1*x2*x3);
x5=IKsin(j[3]);
x6=IKsin(j[0]);
x7=IKsin(j[2]);
x8=(x6*x7);
x9=((1.0)*x8);
x10=IKcos(j[1]);
x11=IKcos(j[2]);
x12=((1.0)*x11);
x13=(x12*x2);
x14=(x5*((x9+(((-1.0)*(1.0)*x10*x13)))));
x15=(x14+x4);
x16=IKsin(j[5]);
x17=IKsin(j[4]);
x18=(x12*x6);
x19=(x2*x7);
x20=((1.0)*x19);
x21=(x18+((x10*x20)));
x22=(x17*x21);
x23=IKcos(j[4]);
x24=((1.0)*x23);
x25=(x1*x5);
x26=(x2*x25);
x27=(x10*x11);
x28=(x2*x27);
x29=(x3*(((((-1.0)*(1.0)*x9))+x28)));
x30=((((-1.0)*(1.0)*x29))+(((-1.0)*(1.0)*x26)));
x31=IKcos(j[6]);
x32=(x17*((x26+x29)));
x33=IKsin(j[6]);
x34=(x23*x30);
x35=(((x0*((x34+x22))))+((x15*x16)));
x36=((0.42)*x1);
x37=(x1*x6);
x38=(x3*x37);
x39=(x5*(((((-1.0)*(1.0)*x20))+(((-1.0)*(1.0)*x10*x18)))));
x40=(x39+x38);
x41=((((-1.0)*(1.0)*x13))+((x10*x9)));
x42=(x17*x41);
x43=(x37*x5);
x44=(x27*x6);
x45=(x3*((x19+x44)));
x46=((((-1.0)*(1.0)*x45))+(((-1.0)*(1.0)*x43)));
x47=(x17*((x43+x45)));
x48=(x23*x46);
x49=(((x0*((x42+x48))))+((x16*x40)));
x50=(x10*x3);
x51=(x11*x25);
x52=(x51+x50);
x53=(x1*x17*x7);
x54=((1.0)*x53);
x55=(x10*x5);
x56=(x1*x12*x3);
x57=((((-1.0)*(1.0)*x55))+x56);
x58=(x1*x24*x7);
x59=(x17*(((((-1.0)*(1.0)*x56))+x55)));
x60=(x23*x57);
x61=(((x0*((x60+(((-1.0)*(1.0)*x54))))))+((x16*x52)));
eerot[0]=(((x16*(((((-1.0)*(1.0)*x24*x30))+(((-1.0)*(1.0)*x22))))))+((x0*x15)));
eerot[1]=(((x33*x35))+((x31*(((((-1.0)*(1.0)*x21*x24))+(((-1.0)*(1.0)*x32)))))));
eerot[2]=(((x33*((x32+((x21*x23))))))+((x31*x35)));
eetrans[0]=(((x5*(((((0.4)*x8))+(((-1.0)*(0.4)*x28))))))+((x16*(((((-1.0)*(0.126)*x22))+(((-1.0)*(0.126)*x34))))))+((x2*x36))+((x0*(((((0.126)*x4))+(((0.126)*x14))))))+(((0.4)*x4)));
eerot[3]=(((x16*(((((-1.0)*(1.0)*x42))+(((-1.0)*(1.0)*x24*x46))))))+((x0*x40)));
eerot[4]=(((x33*x49))+((x31*(((((-1.0)*(1.0)*x24*x41))+(((-1.0)*(1.0)*x47)))))));
eerot[5]=(((x31*x49))+((x33*((((x23*x41))+x47)))));
eetrans[1]=((((0.4)*x38))+((x36*x6))+((x16*(((((-1.0)*(0.126)*x42))+(((-1.0)*(0.126)*x48))))))+((x0*(((((0.126)*x38))+(((0.126)*x39))))))+((x5*(((((-1.0)*(0.4)*x44))+(((-1.0)*(0.4)*x19)))))));
eerot[6]=(((x0*x52))+((x16*(((((-1.0)*(1.0)*x24*x57))+x54)))));
eerot[7]=(((x33*x61))+((x31*(((((-1.0)*(1.0)*x59))+x58)))));
eerot[8]=(((x31*x61))+((x33*(((((-1.0)*(1.0)*x58))+x59)))));
eetrans[2]=((0.36)+((x16*(((((0.126)*x53))+(((-1.0)*(0.126)*x60))))))+(((0.42)*x10))+(((0.4)*x50))+(((0.4)*x51))+((x0*(((((0.126)*x50))+(((0.126)*x51)))))));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {2}; return freeparams; }
IKFAST_API int GetNumJoints() { return 7; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,j2,cj2,sj2,htj2,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6,_ij2[2], _nj2;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1;  _ij2[0] = -1; _ij2[1] = -1; _nj2 = 0;
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j2=pfree[0]; cj2=cos(pfree[0]); sj2=sin(pfree[0]), htj2=tan(pfree[0]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r02;
new_r01=((-1.0)*(((1.0)*r01)));
new_r02=r00;
new_px=((((-1.0)*(0.126)*r00))+px);
new_r10=r12;
new_r11=((-1.0)*(((1.0)*r11)));
new_r12=r10;
new_py=(py+(((-1.0)*(0.126)*r10)));
new_r20=r22;
new_r21=((-1.0)*(((1.0)*r21)));
new_r22=r20;
new_pz=((-0.36)+(((-1.0)*(0.126)*r20))+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x62=((1.0)*py);
IkReal x63=((1.0)*pz);
IkReal x64=((1.0)*px);
pp=((pz*pz)+(py*py)+(px*px));
npx=(((pz*r20))+((py*r10))+((px*r00)));
npy=(((pz*r21))+((py*r11))+((px*r01)));
npz=(((px*r02))+((pz*r22))+((py*r12)));
rxp0_0=((((-1.0)*r20*x62))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x63)));
rxp0_2=(((py*r00))+(((-1.0)*r10*x64)));
rxp1_0=((((-1.0)*r21*x62))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x63)));
rxp1_2=(((py*r01))+(((-1.0)*r11*x64)));
rxp2_0=((((-1.0)*r22*x62))+((pz*r12)));
rxp2_1=((((-1.0)*r02*x63))+((px*r22)));
rxp2_2=((((-1.0)*r12*x64))+((py*r02)));
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
cj3array[0]=((-1.00119047619048)+(((2.97619047619048)*pp)));
if( cj3array[0] >= -1-IKFAST_SINCOS_THRESH && cj3array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( std::isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break;
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
IkReal j0eval[2];
j0eval[0]=((IKabs(py))+(IKabs(px)));
j0eval[1]=((py*py)+(px*px));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
j1eval[0]=((((2.5)*(IKabs(((-0.42)+(((-1.0)*(0.4)*cj3)))))))+(IKabs((cj2*sj3))));
j1eval[1]=((1.1025)+(((2.1)*cj3))+(((cj2*cj2)*(sj3*sj3)))+(cj3*cj3));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j0eval[2];
IkReal x65=cj2*cj2;
IkReal x66=(px*py);
IkReal x67=sj2*sj2;
IkReal x68=py*py;
IkReal x69=cj2*cj2*cj2*cj2;
IkReal x70=py*py*py*py;
IkReal x71=sj2*sj2*sj2*sj2;
IkReal x72=px*px;
IkReal x73=(x68*x72);
IkReal x74=((2.0)*x67);
j0eval[0]=((IKabs((((x65*x66))+((x66*x67)))))+(IKabs((((x65*x68))+((x67*x68))))));
j0eval[1]=(((x70*x71))+((x69*x70))+((x71*x73))+((x65*x68*x72*x74))+((x69*x73))+((x65*x70*x74)));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j0, j1]

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x75=cj2*cj2;
IkReal x76=((1.0)*(py*py));
IkReal x77=sj2*sj2;
IkReal x78=((((-1.0)*x76*x77))+(((-1.0)*x75*x76)));
IkReal x79=(px*py);
IkReal x80=(((x77*x79))+((x75*x79)));
CheckValue<IkReal> x83 = IKatan2WithCheck(IkReal(x78),x80,IKFAST_ATAN2_MAGTHRESH);
if(!x83.valid){
continue;
}
IkReal x81=((-1.0)*(x83.value));
if((((x78*x78)+(x80*x80))) < -0.00001)
continue;
CheckValue<IkReal> x84=IKPowWithIntegerCheck(IKabs(IKsqrt(((x78*x78)+(x80*x80)))),-1);
if(!x84.valid){
continue;
}
if( (((0.4)*py*sj2*sj3*(x84.value))) < -1-IKFAST_SINCOS_THRESH || (((0.4)*py*sj2*sj3*(x84.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x82=IKasin(((0.4)*py*sj2*sj3*(x84.value)));
j0array[0]=(x81+x82);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x81+(((-1.0)*x82)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x85=IKsin(j0);
IkReal x86=((0.4)*sj2*sj3);
IkReal x87=IKcos(j0);
IkReal x88=cj2*cj2;
IkReal x89=px*px;
IkReal x90=sj2*sj2;
IkReal x91=((1.0)*px*py);
evalcond[0]=((((-1.0)*py*x87))+(((-1.0)*x86))+((px*x85)));
evalcond[1]=((((-1.0)*px*x86))+((x85*((((x89*x90))+((x88*x89))))))+((x87*(((((-1.0)*x88*x91))+(((-1.0)*x90*x91)))))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[3];
IkReal x92=(cj0*px);
IkReal x93=(py*sj0);
IkReal x94=(cj2*sj3);
IkReal x95=(pz*x94);
IkReal x96=(cj0*cj3*px);
IkReal x97=(cj3*py*sj0);
IkReal x98=((5.0)*pz);
j1eval[0]=((((-1.05)*x93))+x95+(((-1.0)*x96))+(((-1.05)*x92))+(((-1.0)*x97)));
j1eval[1]=((IKabs(((((0.8)*cj3*x94))+(((-1.0)*x93*x98))+(((-1.0)*x92*x98))+(((0.84)*x94)))))+(IKabs(((-0.882)+(((5.0)*(pz*pz)))+(((-1.0)*(0.8)*(cj3*cj3)))+(((-1.0)*(1.68)*cj3))))));
j1eval[2]=IKsign(((((2.0)*x95))+(((-2.1)*x92))+(((-2.0)*x97))+(((-2.0)*x96))+(((-2.1)*x93))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
IkReal x99=(cj0*px);
IkReal x100=(py*sj0);
IkReal x101=(cj2*sj3);
IkReal x102=(pz*x101);
IkReal x103=(cj0*cj3*px);
IkReal x104=(cj3*py*sj0);
IkReal x105=((50.0)*pp);
IkReal x106=((105.0)*pz);
j1eval[0]=(x102+(((-1.05)*x99))+(((-1.0)*x103))+(((-1.05)*x100))+(((-1.0)*x104)));
j1eval[1]=IKsign(((((-42.0)*x104))+(((-44.1)*x100))+(((-42.0)*x103))+(((-44.1)*x99))+(((42.0)*x102))));
j1eval[2]=((IKabs(((-0.861)+(((-1.0)*cj3*x105))+(((-1.0)*(0.82)*cj3))+(((105.0)*(pz*pz)))+(((-1.0)*(52.5)*pp)))))+(IKabs((((x101*x105))+(((-1.0)*x100*x106))+(((-1.0)*x106*x99))+(((0.82)*x101))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
IkReal x107=cj2*cj2;
IkReal x108=cj3*cj3;
IkReal x109=((4.0)*x107);
IkReal x110=((10.0)*cj3);
IkReal x111=(cj0*px);
IkReal x112=((10.0)*cj2*sj3);
IkReal x113=(py*sj0);
j1eval[0]=((1.1025)+x107+x108+(((2.1)*cj3))+(((-1.0)*x107*x108)));
j1eval[1]=IKsign(((4.41)+x109+(((4.0)*x108))+(((-1.0)*x108*x109))+(((8.4)*cj3))));
j1eval[2]=((IKabs((((x110*x111))+((pz*x112))+(((10.5)*x111))+(((10.5)*x113))+((x110*x113)))))+(IKabs(((((10.5)*pz))+(((-1.0)*x112*x113))+(((-1.0)*x111*x112))+((pz*x110))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x114=((4.0)*(cj2*cj2));
IkReal x115=cj3*cj3;
IkReal x116=(cj0*px);
IkReal x117=(py*sj0);
IkReal x118=((10.0)*cj3);
IkReal x119=((10.0)*cj2*sj3);
CheckValue<IkReal> x120 = IKatan2WithCheck(IkReal((((x116*x118))+(((10.5)*x116))+((pz*x119))+(((10.5)*x117))+((x117*x118)))),((((10.5)*pz))+((pz*x118))+(((-1.0)*x117*x119))+(((-1.0)*x116*x119))),IKFAST_ATAN2_MAGTHRESH);
if(!x120.valid){
continue;
}
CheckValue<IkReal> x121=IKPowWithIntegerCheck(IKsign(((4.41)+(((-1.0)*x114*x115))+(((4.0)*x115))+(((8.4)*cj3))+x114)),-1);
if(!x121.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x120.value)+(((1.5707963267949)*(x121.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break;
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x122=IKcos(j1);
IkReal x123=((0.4)*cj3);
IkReal x124=IKsin(j1);
IkReal x125=((0.4)*cj2*sj3);
IkReal x126=(pz*x122);
IkReal x127=((0.84)*x124);
IkReal x128=((1.0)*cj0);
IkReal x129=(px*x128);
IkReal x130=((1.0)*sj0);
IkReal x131=(py*x130);
IkReal x132=(pz*x124);
IkReal x133=((1.0)*cj0*px*x122);
IkReal x134=((1.0)*py*sj0*x122);
evalcond[0]=((((-1.0)*x122*x123))+(((-1.0)*x124*x125))+pz+(((-0.42)*x122)));
evalcond[1]=((-0.0164)+((cj0*px*x127))+((py*sj0*x127))+(((0.84)*x126))+(((-1.0)*(1.0)*pp)));
evalcond[2]=((0.42)+x123+(((-1.0)*x124*x131))+(((-1.0)*x124*x129))+(((-1.0)*x126)));
evalcond[3]=((((-1.0)*x122*x125))+(((0.42)*x124))+(((-1.0)*x131))+(((-1.0)*x129))+((x123*x124)));
evalcond[4]=(((sj2*x132))+(((-1.0)*cj2*px*x130))+(((-1.0)*sj2*x133))+(((-1.0)*sj2*x134))+((cj0*cj2*py)));
evalcond[5]=(((cj2*x132))+(((-1.0)*cj2*x134))+(((-1.0)*(0.4)*sj3))+((px*sj0*sj2))+(((-1.0)*py*sj2*x128))+(((-1.0)*cj2*x133)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x554=(cj0*px);
IkReal x555=(py*sj0);
IkReal x556=((42.0)*cj3);
IkReal x557=(cj2*sj3);
IkReal x558=((50.0)*pp);
IkReal x559=((105.0)*pz);
CheckValue<IkReal> x560=IKPowWithIntegerCheck(IKsign(((((-1.0)*x554*x556))+(((-44.1)*x554))+(((-44.1)*x555))+(((-1.0)*x555*x556))+(((42.0)*pz*x557)))),-1);
if(!x560.valid){
continue;
}
CheckValue<IkReal> x561 = IKatan2WithCheck(IkReal(((-0.861)+(((-1.0)*cj3*x558))+(((-1.0)*(0.82)*cj3))+(((105.0)*(pz*pz)))+(((-1.0)*(52.5)*pp)))),((((-1.0)*x554*x559))+((x557*x558))+(((-1.0)*x555*x559))+(((0.82)*x557))),IKFAST_ATAN2_MAGTHRESH);
if(!x561.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x560.value)))+(x561.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break;
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x562=IKcos(j1);
IkReal x563=((0.4)*cj3);
IkReal x564=IKsin(j1);
IkReal x565=((0.4)*cj2*sj3);
IkReal x566=(pz*x562);
IkReal x567=((0.84)*x564);
IkReal x568=((1.0)*cj0);
IkReal x569=(px*x568);
IkReal x570=((1.0)*sj0);
IkReal x571=(py*x570);
IkReal x572=(pz*x564);
IkReal x573=((1.0)*cj0*px*x562);
IkReal x574=((1.0)*py*sj0*x562);
evalcond[0]=((((-1.0)*x564*x565))+(((-0.42)*x562))+pz+(((-1.0)*x562*x563)));
evalcond[1]=((-0.0164)+((py*sj0*x567))+((cj0*px*x567))+(((0.84)*x566))+(((-1.0)*(1.0)*pp)));
evalcond[2]=((0.42)+(((-1.0)*x564*x569))+(((-1.0)*x566))+(((-1.0)*x564*x571))+x563);
evalcond[3]=((((-1.0)*x569))+(((-1.0)*x562*x565))+((x563*x564))+(((0.42)*x564))+(((-1.0)*x571)));
evalcond[4]=(((sj2*x572))+(((-1.0)*cj2*px*x570))+(((-1.0)*sj2*x573))+(((-1.0)*sj2*x574))+((cj0*cj2*py)));
evalcond[5]=((((-1.0)*py*sj2*x568))+(((-1.0)*(0.4)*sj3))+((px*sj0*sj2))+(((-1.0)*cj2*x573))+(((-1.0)*cj2*x574))+((cj2*x572)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x575=(cj0*px);
IkReal x576=(py*sj0);
IkReal x577=((2.0)*cj3);
IkReal x578=(cj2*sj3);
IkReal x579=((5.0)*pz);
CheckValue<IkReal> x580=IKPowWithIntegerCheck(IKsign(((((-2.1)*x576))+(((-2.1)*x575))+(((-1.0)*x575*x577))+(((2.0)*pz*x578))+(((-1.0)*x576*x577)))),-1);
if(!x580.valid){
continue;
}
CheckValue<IkReal> x581 = IKatan2WithCheck(IkReal(((-0.882)+(((5.0)*(pz*pz)))+(((-1.0)*(0.8)*(cj3*cj3)))+(((-1.0)*(1.68)*cj3)))),((((-1.0)*x576*x579))+(((-1.0)*x575*x579))+(((0.8)*cj3*x578))+(((0.84)*x578))),IKFAST_ATAN2_MAGTHRESH);
if(!x581.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x580.value)))+(x581.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break;
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x582=IKcos(j1);
IkReal x583=((0.4)*cj3);
IkReal x584=IKsin(j1);
IkReal x585=((0.4)*cj2*sj3);
IkReal x586=(pz*x582);
IkReal x587=((0.84)*x584);
IkReal x588=((1.0)*cj0);
IkReal x589=(px*x588);
IkReal x590=((1.0)*sj0);
IkReal x591=(py*x590);
IkReal x592=(pz*x584);
IkReal x593=((1.0)*cj0*px*x582);
IkReal x594=((1.0)*py*sj0*x582);
evalcond[0]=((((-1.0)*x584*x585))+pz+(((-1.0)*x582*x583))+(((-0.42)*x582)));
evalcond[1]=((-0.0164)+((py*sj0*x587))+(((0.84)*x586))+(((-1.0)*(1.0)*pp))+((cj0*px*x587)));
evalcond[2]=((0.42)+(((-1.0)*x586))+(((-1.0)*x584*x591))+(((-1.0)*x584*x589))+x583);
evalcond[3]=(((x583*x584))+(((-1.0)*x582*x585))+(((0.42)*x584))+(((-1.0)*x589))+(((-1.0)*x591)));
evalcond[4]=(((sj2*x592))+(((-1.0)*sj2*x593))+(((-1.0)*sj2*x594))+(((-1.0)*cj2*px*x590))+((cj0*cj2*py)));
evalcond[5]=((((-1.0)*py*sj2*x588))+(((-1.0)*(0.4)*sj3))+((px*sj0*sj2))+(((-1.0)*cj2*x593))+(((-1.0)*cj2*x594))+((cj2*x592)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x595=((-0.42)+(((-1.0)*(0.4)*cj3)));
CheckValue<IkReal> x598 = IKatan2WithCheck(IkReal(x595),((-1.0)*(((0.4)*cj2*sj3))),IKFAST_ATAN2_MAGTHRESH);
if(!x598.valid){
continue;
}
IkReal x596=((-1.0)*(x598.value));
if((((x595*x595)+(((0.16)*(cj2*cj2)*(sj3*sj3))))) < -0.00001)
continue;
CheckValue<IkReal> x599=IKPowWithIntegerCheck(IKabs(IKsqrt(((x595*x595)+(((0.16)*(cj2*cj2)*(sj3*sj3)))))),-1);
if(!x599.valid){
continue;
}
if( ((pz*(x599.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x599.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x597=IKasin((pz*(x599.value)));
j1array[0]=((((-1.0)*x597))+x596);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+x596+x597);
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break;
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j0eval[3];
IkReal x600=((((-1.0)*(1.0)*sj1*(pz*pz)))+((pp*sj1)));
IkReal x601=((0.4)*cj3);
IkReal x602=((1.0)*cj1*pz);
IkReal x603=((0.4)*sj1*sj2*sj3);
j0eval[0]=x600;
j0eval[1]=IKsign(x600);
j0eval[2]=((IKabs((((px*x603))+(((-1.0)*py*x602))+(((0.42)*py))+((py*x601)))))+(IKabs(((((-1.0)*py*x603))+(((-1.0)*px*x602))+((px*x601))+(((0.42)*px))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
IkReal x604=(pp*sj1);
IkReal x605=(sj1*(pz*pz));
IkReal x606=((125.0)*pp);
IkReal x607=((105.0)*cj1*pz);
IkReal x608=((42.0)*sj1*sj2*sj3);
j0eval[0]=((((-1.0)*x605))+x604);
j0eval[1]=IKsign(((((-105.0)*x605))+(((105.0)*x604))));
j0eval[2]=((IKabs((((px*x608))+(((2.05)*py))+(((-1.0)*py*x607))+((py*x606)))))+(IKabs(((((-1.0)*px*x607))+(((2.05)*px))+((px*x606))+(((-1.0)*py*x608))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
IkReal x609=(pp+(((-1.0)*(1.0)*(pz*pz))));
IkReal x610=((0.42)*sj1);
IkReal x611=((0.4)*cj3*sj1);
IkReal x612=((0.4)*sj2*sj3);
IkReal x613=((0.4)*cj1*cj2*sj3);
j0eval[0]=x609;
j0eval[1]=((IKabs((((py*x610))+((px*x612))+((py*x611))+(((-1.0)*py*x613)))))+(IKabs((((px*x611))+(((-1.0)*px*x613))+(((-1.0)*py*x612))+((px*x610))))));
j0eval[2]=IKsign(x609);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
IkReal x614=((-1.0)*(((1.0)*pp)));
IkReal x615=((0.4)*cj3);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=((0.3364)+x614+(((0.336)*cj3)));
evalcond[2]=((-0.42)+(((-1.0)*x615))+pz);
evalcond[3]=((-0.0164)+x614+(((0.84)*pz)));
evalcond[4]=((0.42)+x615+(((-1.0)*(1.0)*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=0;
cj1=1.0;
j1=0;
IkReal x616=pz*pz;
IkReal x617=(px*sj3);
IkReal x618=(py*sj3);
j0eval[0]=(pp+(((-1.0)*x616)));
j0eval[1]=IKsign(((((-5.0)*x616))+(((5.0)*pp))));
j0eval[2]=((IKabs((((sj2*x617))+(((-1.0)*cj2*x618)))))+(IKabs((((sj2*x618))+((cj2*x617))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj1=0;
cj1=1.0;
j1=0;
IkReal x619=(cj2*pp);
IkReal x620=(cj2*(pz*pz));
IkReal x621=(cj2*sj2*sj3);
IkReal x622=(sj3*(cj2*cj2));
j0eval[0]=(x619+(((-1.0)*x620)));
j0eval[1]=IKsign(((((5.0)*x619))+(((-5.0)*x620))));
j0eval[2]=((IKabs((((px*x622))+((py*x621)))))+(IKabs((((px*x621))+(((-1.0)*py*x622))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj1=0;
cj1=1.0;
j1=0;
IkReal x623=(cj2*pp);
IkReal x624=(cj2*(pz*pz));
IkReal x625=(py*sj3);
IkReal x626=cj2*cj2;
IkReal x627=(px*sj3);
j0eval[0]=((((-1.0)*x623))+x624);
j0eval[1]=((IKabs(((((-1.0)*cj2*sj2*x627))+((x625*x626)))))+(IKabs((((cj2*sj2*x625))+((x626*x627))))));
j0eval[2]=IKsign(((((-5.0)*x623))+(((5.0)*x624))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
IkReal x628=((-1.0)*(((1.0)*pp)));
IkReal x629=((0.4)*cj3);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=((0.3364)+(((0.336)*cj3))+x628);
evalcond[2]=((-0.42)+pz+(((-1.0)*x629)));
evalcond[3]=((-0.0164)+x628+(((0.84)*pz)));
evalcond[4]=((0.42)+(((-1.0)*(1.0)*pz))+x629);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[4];
sj1=0;
cj1=1.0;
j1=0;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
IkReal x630=pz*pz;
j0eval[0]=((((-1.0)*x630))+pp);
j0eval[1]=4.0;
j0eval[2]=sj3;
j0eval[3]=IKsign(((((-5.0)*x630))+(((5.0)*pp))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x631=((-1.0)*(((1.0)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=((0.6724)+x631);
evalcond[2]=((-0.82)+pz);
evalcond[3]=((-0.0164)+x631+(((0.84)*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=0;
cj3=1.0;
j3=0;
j0eval[0]=((IKabs(py))+(IKabs(px)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x633 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*py)))),px,IKFAST_ATAN2_MAGTHRESH);
if(!x633.valid){
continue;
}
IkReal x632=((-1.0)*(x633.value));
j0array[0]=x632;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x632);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*py*(IKsin(j0))))+(((-1.0)*(1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x634=((-1.0)*(((1.0)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=((0.0004)+x634);
evalcond[2]=((-0.02)+pz);
evalcond[3]=((-0.0164)+x634+(((0.84)*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j0eval[0]=((IKabs(py))+(IKabs(px)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x636 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*py)))),px,IKFAST_ATAN2_MAGTHRESH);
if(!x636.valid){
continue;
}
IkReal x635=((-1.0)*(x636.value));
j0array[0]=x635;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x635);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*py*(IKsin(j0))))+(((-1.0)*(1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x637=((2.0)*sj3);
CheckValue<IkReal> x638=IKPowWithIntegerCheck(IKsign(((((-1.0)*(5.0)*(pz*pz)))+(((5.0)*pp)))),-1);
if(!x638.valid){
continue;
}
CheckValue<IkReal> x639 = IKatan2WithCheck(IkReal((px*x637)),((-1.0)*py*x637),IKFAST_ATAN2_MAGTHRESH);
if(!x639.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x638.value)))+(x639.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x640=((1.0)*(IKcos(j0)));
IkReal x641=IKsin(j0);
evalcond[0]=((((-1.0)*py*x641))+(((-1.0)*px*x640)));
evalcond[1]=((((-1.0)*py*x640))+((px*x641))+(((-1.0)*(0.4)*sj3)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x642=((-1.0)*(((1.0)*pp)));
IkReal x643=((0.4)*cj3);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=((0.3364)+(((0.336)*cj3))+x642);
evalcond[2]=((-0.42)+(((-1.0)*x643))+pz);
evalcond[3]=((-0.0164)+x642+(((0.84)*pz)));
evalcond[4]=((0.42)+(((-1.0)*(1.0)*pz))+x643);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[4];
sj1=0;
cj1=1.0;
j1=0;
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
IkReal x644=pz*pz;
j0eval[0]=(pp+(((-1.0)*x644)));
j0eval[1]=IKsign(((((-5.0)*x644))+(((5.0)*pp))));
j0eval[2]=4.0;
j0eval[3]=sj3;
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x645=((-1.0)*(((1.0)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=((0.6724)+x645);
evalcond[2]=((-0.82)+pz);
evalcond[3]=((-0.0164)+x645+(((0.84)*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
sj3=0;
cj3=1.0;
j3=0;
j0eval[0]=((IKabs(py))+(IKabs(px)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x647 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*py)))),px,IKFAST_ATAN2_MAGTHRESH);
if(!x647.valid){
continue;
}
IkReal x646=((-1.0)*(x647.value));
j0array[0]=x646;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x646);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*py*(IKsin(j0))))+(((-1.0)*(1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x648=((-1.0)*(((1.0)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=((0.0004)+x648);
evalcond[2]=((-0.02)+pz);
evalcond[3]=((-0.0164)+x648+(((0.84)*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j0eval[0]=((IKabs(py))+(IKabs(px)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x650 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*py)))),px,IKFAST_ATAN2_MAGTHRESH);
if(!x650.valid){
continue;
}
IkReal x649=((-1.0)*(x650.value));
j0array[0]=x649;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x649);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*py*(IKsin(j0))))+(((-1.0)*(1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x651=((2.0)*sj3);
CheckValue<IkReal> x652=IKPowWithIntegerCheck(IKsign(((((-1.0)*(5.0)*(pz*pz)))+(((5.0)*pp)))),-1);
if(!x652.valid){
continue;
}
CheckValue<IkReal> x653 = IKatan2WithCheck(IkReal(((-1.0)*px*x651)),(py*x651),IKFAST_ATAN2_MAGTHRESH);
if(!x653.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x652.value)))+(x653.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x654=((1.0)*(IKcos(j0)));
IkReal x655=IKsin(j0);
evalcond[0]=((((-1.0)*py*x655))+(((-1.0)*px*x654)));
evalcond[1]=((((0.4)*sj3))+((px*x655))+(((-1.0)*py*x654)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x656=((-1.0)*(((1.0)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=((0.6724)+x656);
evalcond[2]=((-0.82)+pz);
evalcond[3]=((-0.0164)+x656+(((0.84)*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
sj3=0;
cj3=1.0;
j3=0;
j0eval[0]=((IKabs(py))+(IKabs(px)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
sj3=0;
cj3=1.0;
j3=0;
IkReal x657=((1.0)*px);
j0eval[0]=((IKabs(((((-1.0)*sj2*x657))+((cj2*py)))))+(IKabs(((((-1.0)*(1.0)*py*sj2))+(((-1.0)*cj2*x657))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
sj3=0;
cj3=1.0;
j3=0;
IkReal x658=((1.0)*cj2);
j0eval[0]=((IKabs(((((-1.0)*py*x658))+((px*sj2)))))+(IKabs(((((-1.0)*px*x658))+(((-1.0)*(1.0)*py*sj2))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x659=((1.0)*cj2);
CheckValue<IkReal> x661 = IKatan2WithCheck(IkReal(((((-1.0)*px*x659))+(((-1.0)*(1.0)*py*sj2)))),((((-1.0)*py*x659))+((px*sj2))),IKFAST_ATAN2_MAGTHRESH);
if(!x661.valid){
continue;
}
IkReal x660=((-1.0)*(x661.value));
j0array[0]=x660;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x660);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x662=IKsin(j0);
IkReal x663=(px*x662);
IkReal x664=IKcos(j0);
IkReal x665=((1.0)*x664);
IkReal x666=(px*x665);
IkReal x667=((1.0)*py*x662);
evalcond[0]=((((-1.0)*py*x665))+x663);
evalcond[1]=((((-1.0)*x666))+(((-1.0)*x667)));
evalcond[2]=((((-1.0)*sj2*x666))+(((-1.0)*sj2*x667))+((cj2*py*x664))+(((-1.0)*cj2*x663)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x668=((1.0)*px);
CheckValue<IkReal> x670 = IKatan2WithCheck(IkReal((((cj2*py))+(((-1.0)*sj2*x668)))),((((-1.0)*cj2*x668))+(((-1.0)*(1.0)*py*sj2))),IKFAST_ATAN2_MAGTHRESH);
if(!x670.valid){
continue;
}
IkReal x669=((-1.0)*(x670.value));
j0array[0]=x669;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x669);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x671=IKsin(j0);
IkReal x672=(px*x671);
IkReal x673=((1.0)*(IKcos(j0)));
IkReal x674=(py*x673);
IkReal x675=(px*x673);
IkReal x676=((1.0)*py*x671);
evalcond[0]=((((-1.0)*x674))+x672);
evalcond[1]=((((-1.0)*x675))+(((-1.0)*x676)));
evalcond[2]=((((-1.0)*sj2*x674))+((sj2*x672))+(((-1.0)*cj2*x676))+(((-1.0)*cj2*x675)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x678 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*py)))),px,IKFAST_ATAN2_MAGTHRESH);
if(!x678.valid){
continue;
}
IkReal x677=((-1.0)*(x678.value));
j0array[0]=x677;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x677);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x679=IKcos(j0);
IkReal x680=((1.0)*px);
IkReal x681=(x679*x680);
IkReal x682=IKsin(j0);
IkReal x683=((1.0)*py*x682);
IkReal x684=(py*x679);
evalcond[0]=((((-1.0)*x681))+(((-1.0)*x683)));
evalcond[1]=((((-1.0)*sj2*x681))+(((-1.0)*sj2*x683))+((cj2*x684))+(((-1.0)*cj2*x680*x682)));
evalcond[2]=((((-1.0)*sj2*x684))+(((-1.0)*cj2*x683))+((px*sj2*x682))+(((-1.0)*cj2*x681)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x685=((-1.0)*(((1.0)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=((0.0004)+x685);
evalcond[2]=((-0.02)+pz);
evalcond[3]=((-0.0164)+x685+(((0.84)*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j0eval[0]=((IKabs(py))+(IKabs(px)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x686=((1.0)*px);
j0eval[0]=((IKabs(((((-1.0)*cj2*x686))+(((-1.0)*(1.0)*py*sj2)))))+(IKabs(((((-1.0)*sj2*x686))+((cj2*py))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x687=((1.0)*cj2);
j0eval[0]=((IKabs(((((-1.0)*py*x687))+((px*sj2)))))+(IKabs(((((-1.0)*(1.0)*py*sj2))+(((-1.0)*px*x687))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x688=((1.0)*cj2);
CheckValue<IkReal> x690 = IKatan2WithCheck(IkReal(((((-1.0)*(1.0)*py*sj2))+(((-1.0)*px*x688)))),((((-1.0)*py*x688))+((px*sj2))),IKFAST_ATAN2_MAGTHRESH);
if(!x690.valid){
continue;
}
IkReal x689=((-1.0)*(x690.value));
j0array[0]=x689;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x689);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x691=IKsin(j0);
IkReal x692=(px*x691);
IkReal x693=IKcos(j0);
IkReal x694=((1.0)*x693);
IkReal x695=(px*x694);
IkReal x696=((1.0)*py*x691);
evalcond[0]=(x692+(((-1.0)*py*x694)));
evalcond[1]=((((-1.0)*x695))+(((-1.0)*x696)));
evalcond[2]=((((-1.0)*sj2*x695))+(((-1.0)*sj2*x696))+(((-1.0)*cj2*x692))+((cj2*py*x693)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
IkReal x697=((1.0)*px);
CheckValue<IkReal> x699 = IKatan2WithCheck(IkReal(((((-1.0)*sj2*x697))+((cj2*py)))),((((-1.0)*(1.0)*py*sj2))+(((-1.0)*cj2*x697))),IKFAST_ATAN2_MAGTHRESH);
if(!x699.valid){
continue;
}
IkReal x698=((-1.0)*(x699.value));
j0array[0]=x698;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x698);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x700=IKsin(j0);
IkReal x701=(px*x700);
IkReal x702=((1.0)*(IKcos(j0)));
IkReal x703=(py*x702);
IkReal x704=(px*x702);
IkReal x705=((1.0)*py*x700);
evalcond[0]=(x701+(((-1.0)*x703)));
evalcond[1]=((((-1.0)*x704))+(((-1.0)*x705)));
evalcond[2]=((((-1.0)*cj2*x704))+(((-1.0)*sj2*x703))+(((-1.0)*cj2*x705))+((sj2*x701)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x707 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*py)))),px,IKFAST_ATAN2_MAGTHRESH);
if(!x707.valid){
continue;
}
IkReal x706=((-1.0)*(x707.value));
j0array[0]=x706;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x706);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x708=IKcos(j0);
IkReal x709=((1.0)*px);
IkReal x710=(x708*x709);
IkReal x711=IKsin(j0);
IkReal x712=((1.0)*py*x711);
IkReal x713=(py*x708);
evalcond[0]=((((-1.0)*x710))+(((-1.0)*x712)));
evalcond[1]=((((-1.0)*cj2*x709*x711))+((cj2*x713))+(((-1.0)*sj2*x710))+(((-1.0)*sj2*x712)));
evalcond[2]=((((-1.0)*sj2*x713))+(((-1.0)*cj2*x710))+((px*sj2*x711))+(((-1.0)*cj2*x712)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x714=((5.0)*cj2);
IkReal x715=((2.0)*cj2*sj2*sj3);
IkReal x716=((2.0)*sj3*(cj2*cj2));
CheckValue<IkReal> x717=IKPowWithIntegerCheck(IKsign(((((-1.0)*pp*x714))+((x714*(pz*pz))))),-1);
if(!x717.valid){
continue;
}
CheckValue<IkReal> x718 = IKatan2WithCheck(IkReal((((py*x716))+(((-1.0)*px*x715)))),(((px*x716))+((py*x715))),IKFAST_ATAN2_MAGTHRESH);
if(!x718.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x717.value)))+(x718.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[4];
IkReal x719=IKsin(j0);
IkReal x720=(px*x719);
IkReal x721=((0.4)*sj3);
IkReal x722=IKcos(j0);
IkReal x723=((1.0)*x722);
IkReal x724=(py*x723);
IkReal x725=(px*x723);
IkReal x726=((1.0)*py*x719);
evalcond[0]=((((-1.0)*sj2*x721))+(((-1.0)*x724))+x720);
evalcond[1]=((((-1.0)*cj2*x721))+(((-1.0)*x726))+(((-1.0)*x725)));
evalcond[2]=(((cj2*py*x722))+(((-1.0)*sj2*x726))+(((-1.0)*sj2*x725))+(((-1.0)*cj2*x720)));
evalcond[3]=((((-1.0)*x721))+(((-1.0)*sj2*x724))+((sj2*x720))+(((-1.0)*cj2*x726))+(((-1.0)*cj2*x725)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x727=((5.0)*cj2);
IkReal x728=((2.0)*cj2*sj2*sj3);
IkReal x729=((2.0)*sj3*(cj2*cj2));
CheckValue<IkReal> x730 = IKatan2WithCheck(IkReal(((((-1.0)*py*x729))+((px*x728)))),((((-1.0)*py*x728))+(((-1.0)*px*x729))),IKFAST_ATAN2_MAGTHRESH);
if(!x730.valid){
continue;
}
CheckValue<IkReal> x731=IKPowWithIntegerCheck(IKsign(((((-1.0)*x727*(pz*pz)))+((pp*x727)))),-1);
if(!x731.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x730.value)+(((1.5707963267949)*(x731.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[4];
IkReal x732=IKsin(j0);
IkReal x733=(px*x732);
IkReal x734=((0.4)*sj3);
IkReal x735=IKcos(j0);
IkReal x736=((1.0)*x735);
IkReal x737=(py*x736);
IkReal x738=(px*x736);
IkReal x739=((1.0)*py*x732);
evalcond[0]=((((-1.0)*x737))+(((-1.0)*sj2*x734))+x733);
evalcond[1]=((((-1.0)*x739))+(((-1.0)*cj2*x734))+(((-1.0)*x738)));
evalcond[2]=(((cj2*py*x735))+(((-1.0)*sj2*x739))+(((-1.0)*cj2*x733))+(((-1.0)*sj2*x738)));
evalcond[3]=((((-1.0)*cj2*x738))+(((-1.0)*sj2*x737))+(((-1.0)*x734))+(((-1.0)*cj2*x739))+((sj2*x733)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x740=((2.0)*cj2*sj3);
IkReal x741=((2.0)*sj2*sj3);
CheckValue<IkReal> x742 = IKatan2WithCheck(IkReal(((((-1.0)*py*x740))+((px*x741)))),((((-1.0)*px*x740))+(((-1.0)*py*x741))),IKFAST_ATAN2_MAGTHRESH);
if(!x742.valid){
continue;
}
CheckValue<IkReal> x743=IKPowWithIntegerCheck(IKsign(((((-1.0)*(5.0)*(pz*pz)))+(((5.0)*pp)))),-1);
if(!x743.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x742.value)+(((1.5707963267949)*(x743.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[4];
IkReal x744=IKsin(j0);
IkReal x745=(px*x744);
IkReal x746=((0.4)*sj3);
IkReal x747=IKcos(j0);
IkReal x748=((1.0)*x747);
IkReal x749=(py*x748);
IkReal x750=(px*x748);
IkReal x751=((1.0)*py*x744);
evalcond[0]=((((-1.0)*x749))+x745+(((-1.0)*sj2*x746)));
evalcond[1]=((((-1.0)*x751))+(((-1.0)*cj2*x746))+(((-1.0)*x750)));
evalcond[2]=(((cj2*py*x747))+(((-1.0)*sj2*x750))+(((-1.0)*cj2*x745))+(((-1.0)*sj2*x751)));
evalcond[3]=((((-1.0)*cj2*x750))+(((-1.0)*x746))+(((-1.0)*cj2*x751))+(((-1.0)*sj2*x749))+((sj2*x745)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x752=((-1.0)*(((1.0)*pp)));
IkReal x753=((0.42)+pz+(((0.4)*cj3)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=((0.3364)+(((0.336)*cj3))+x752);
evalcond[2]=x753;
evalcond[3]=((-0.0164)+x752+(((-1.0)*(0.84)*pz)));
evalcond[4]=x753;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x754=pz*pz;
IkReal x755=(cj2*sj3);
IkReal x756=(sj2*sj3);
j0eval[0]=(pp+(((-1.0)*x754)));
j0eval[1]=((IKabs(((((-1.0)*py*x756))+((px*x755)))))+(IKabs((((px*x756))+((py*x755))))));
j0eval[2]=IKsign(((((-5.0)*x754))+(((5.0)*pp))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x757=(cj2*pp);
IkReal x758=(cj2*(pz*pz));
IkReal x759=(px*sj3);
IkReal x760=cj2*cj2;
IkReal x761=(py*sj3);
j0eval[0]=((((-1.0)*x758))+x757);
j0eval[1]=IKsign(((((5.0)*x757))+(((-5.0)*x758))));
j0eval[2]=((IKabs((((x760*x761))+((cj2*sj2*x759)))))+(IKabs(((((-1.0)*cj2*sj2*x761))+((x759*x760))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x762=(pp*sj2);
IkReal x763=(sj2*(pz*pz));
IkReal x764=(px*sj3);
IkReal x765=(cj2*sj2);
IkReal x766=(py*sj3);
IkReal x767=cj2*cj2;
j0eval[0]=(x762+(((-1.0)*x763)));
j0eval[1]=((IKabs((((x765*x766))+(((-1.0)*x764*x767))+x764)))+(IKabs((((x764*x765))+(((-1.0)*x766))+((x766*x767))))));
j0eval[2]=IKsign(((((5.0)*x762))+(((-5.0)*x763))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
IkReal x768=((-1.0)*(((1.0)*pp)));
IkReal x769=x753;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
evalcond[1]=((0.3364)+(((0.336)*cj3))+x768);
evalcond[2]=x769;
evalcond[3]=((-0.0164)+x768+(((-1.0)*(0.84)*pz)));
evalcond[4]=x769;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[4];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=0;
cj2=1.0;
j2=0;
IkReal x770=pz*pz;
j0eval[0]=(pp+(((-1.0)*x770)));
j0eval[1]=4.0;
j0eval[2]=sj3;
j0eval[3]=IKsign(((((-5.0)*x770))+(((5.0)*pp))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x771=((-1.0)*(((1.0)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=((0.6724)+x771);
evalcond[2]=((0.82)+pz);
evalcond[3]=((-0.0164)+x771+(((-1.0)*(0.84)*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=0;
cj2=1.0;
j2=0;
sj3=0;
cj3=1.0;
j3=0;
j0eval[0]=((IKabs(py))+(IKabs(px)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x773 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*py)))),px,IKFAST_ATAN2_MAGTHRESH);
if(!x773.valid){
continue;
}
IkReal x772=((-1.0)*(x773.value));
j0array[0]=x772;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x772);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*py*(IKsin(j0))))+(((-1.0)*(1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x774=((-1.0)*(((1.0)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=((0.0004)+x774);
evalcond[2]=((0.02)+pz);
evalcond[3]=((-0.0164)+x774+(((-1.0)*(0.84)*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=0;
cj2=1.0;
j2=0;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j0eval[0]=((IKabs(py))+(IKabs(px)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x776 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*py)))),px,IKFAST_ATAN2_MAGTHRESH);
if(!x776.valid){
continue;
}
IkReal x775=((-1.0)*(x776.value));
j0array[0]=x775;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x775);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*py*(IKsin(j0))))+(((-1.0)*(1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x777=((2.0)*sj3);
CheckValue<IkReal> x778=IKPowWithIntegerCheck(IKsign(((((-1.0)*(5.0)*(pz*pz)))+(((5.0)*pp)))),-1);
if(!x778.valid){
continue;
}
CheckValue<IkReal> x779 = IKatan2WithCheck(IkReal((py*x777)),(px*x777),IKFAST_ATAN2_MAGTHRESH);
if(!x779.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x778.value)))+(x779.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x780=IKsin(j0);
IkReal x781=((1.0)*(IKcos(j0)));
evalcond[0]=(((px*x780))+(((-1.0)*py*x781)));
evalcond[1]=((((0.4)*sj3))+(((-1.0)*py*x780))+(((-1.0)*px*x781)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x782=((-1.0)*(((1.0)*pp)));
IkReal x783=x753;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
evalcond[1]=((0.3364)+x782+(((0.336)*cj3)));
evalcond[2]=x783;
evalcond[3]=((-0.0164)+x782+(((-1.0)*(0.84)*pz)));
evalcond[4]=x783;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[4];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
IkReal x784=pz*pz;
j0eval[0]=(pp+(((-1.0)*x784)));
j0eval[1]=4.0;
j0eval[2]=sj3;
j0eval[3]=IKsign(((((-5.0)*x784))+(((5.0)*pp))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x785=((-1.0)*(((1.0)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=((0.6724)+x785);
evalcond[2]=((0.82)+pz);
evalcond[3]=((-0.0164)+x785+(((-1.0)*(0.84)*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=0;
cj3=1.0;
j3=0;
j0eval[0]=((IKabs(py))+(IKabs(px)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x787 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*py)))),px,IKFAST_ATAN2_MAGTHRESH);
if(!x787.valid){
continue;
}
IkReal x786=((-1.0)*(x787.value));
j0array[0]=x786;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x786);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*py*(IKsin(j0))))+(((-1.0)*(1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x788=((-1.0)*(((1.0)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=((0.0004)+x788);
evalcond[2]=((0.02)+pz);
evalcond[3]=((-0.0164)+x788+(((-1.0)*(0.84)*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j0eval[0]=((IKabs(py))+(IKabs(px)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x790 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*py)))),px,IKFAST_ATAN2_MAGTHRESH);
if(!x790.valid){
continue;
}
IkReal x789=((-1.0)*(x790.value));
j0array[0]=x789;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x789);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*py*(IKsin(j0))))+(((-1.0)*(1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x791=((2.0)*sj3);
CheckValue<IkReal> x792=IKPowWithIntegerCheck(IKsign(((((-1.0)*(5.0)*(pz*pz)))+(((5.0)*pp)))),-1);
if(!x792.valid){
continue;
}
CheckValue<IkReal> x793 = IKatan2WithCheck(IkReal(((-1.0)*py*x791)),((-1.0)*px*x791),IKFAST_ATAN2_MAGTHRESH);
if(!x793.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x792.value)))+(x793.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x794=IKsin(j0);
IkReal x795=((1.0)*(IKcos(j0)));
evalcond[0]=((((-1.0)*py*x795))+((px*x794)));
evalcond[1]=((((-1.0)*px*x795))+(((-1.0)*(0.4)*sj3))+(((-1.0)*py*x794)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x796=((-1.0)*(((1.0)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=((0.6724)+x796);
evalcond[2]=((0.82)+pz);
evalcond[3]=((-0.0164)+(((-1.0)*(0.84)*pz))+x796);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj3=0;
cj3=1.0;
j3=0;
j0eval[0]=((IKabs(py))+(IKabs(px)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj3=0;
cj3=1.0;
j3=0;
j0eval[0]=((IKabs((((py*sj2))+(((-1.0)*(1.0)*cj2*px)))))+(IKabs((((px*sj2))+((cj2*py))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj3=0;
cj3=1.0;
j3=0;
j0eval[0]=((IKabs(((((-1.0)*(1.0)*py*sj2))+((cj2*px)))))+(IKabs((((px*sj2))+((cj2*py))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x798 = IKatan2WithCheck(IkReal(((((-1.0)*(1.0)*py*sj2))+((cj2*px)))),(((px*sj2))+((cj2*py))),IKFAST_ATAN2_MAGTHRESH);
if(!x798.valid){
continue;
}
IkReal x797=((-1.0)*(x798.value));
j0array[0]=x797;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x797);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x799=IKsin(j0);
IkReal x800=(px*x799);
IkReal x801=IKcos(j0);
IkReal x802=((1.0)*x801);
IkReal x803=(py*x799);
evalcond[0]=(x800+(((-1.0)*py*x802)));
evalcond[1]=((((-1.0)*px*x802))+(((-1.0)*x803)));
evalcond[2]=(((px*sj2*x801))+((sj2*x803))+((cj2*py*x801))+(((-1.0)*cj2*x800)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x805 = IKatan2WithCheck(IkReal((((px*sj2))+((cj2*py)))),(((py*sj2))+(((-1.0)*(1.0)*cj2*px))),IKFAST_ATAN2_MAGTHRESH);
if(!x805.valid){
continue;
}
IkReal x804=((-1.0)*(x805.value));
j0array[0]=x804;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x804);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x806=IKsin(j0);
IkReal x807=(px*x806);
IkReal x808=IKcos(j0);
IkReal x809=((1.0)*x808);
IkReal x810=(py*x809);
IkReal x811=(py*x806);
evalcond[0]=(x807+(((-1.0)*x810)));
evalcond[1]=((((-1.0)*px*x809))+(((-1.0)*x811)));
evalcond[2]=(((cj2*x811))+(((-1.0)*sj2*x810))+((sj2*x807))+((cj2*px*x808)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x813 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*py)))),px,IKFAST_ATAN2_MAGTHRESH);
if(!x813.valid){
continue;
}
IkReal x812=((-1.0)*(x813.value));
j0array[0]=x812;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x812);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x814=IKcos(j0);
IkReal x815=(px*x814);
IkReal x816=IKsin(j0);
IkReal x817=(py*x816);
IkReal x818=(py*x814);
IkReal x819=(px*x816);
evalcond[0]=((((-1.0)*x815))+(((-1.0)*x817)));
evalcond[1]=(((sj2*x817))+(((-1.0)*cj2*x819))+((cj2*x818))+((sj2*x815)));
evalcond[2]=(((cj2*x815))+(((-1.0)*sj2*x818))+((cj2*x817))+((sj2*x819)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x820=((-1.0)*(((1.0)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=((0.0004)+x820);
evalcond[2]=((0.02)+pz);
evalcond[3]=((-0.0164)+x820+(((-1.0)*(0.84)*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j0eval[0]=((IKabs(py))+(IKabs(px)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j0eval[0]=((IKabs((((py*sj2))+(((-1.0)*(1.0)*cj2*px)))))+(IKabs((((px*sj2))+((cj2*py))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j0eval[0]=((IKabs(((((-1.0)*(1.0)*py*sj2))+((cj2*px)))))+(IKabs((((px*sj2))+((cj2*py))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0]

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x822 = IKatan2WithCheck(IkReal(((((-1.0)*(1.0)*py*sj2))+((cj2*px)))),(((px*sj2))+((cj2*py))),IKFAST_ATAN2_MAGTHRESH);
if(!x822.valid){
continue;
}
IkReal x821=((-1.0)*(x822.value));
j0array[0]=x821;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x821);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x823=IKsin(j0);
IkReal x824=(px*x823);
IkReal x825=IKcos(j0);
IkReal x826=((1.0)*x825);
IkReal x827=(py*x823);
evalcond[0]=(x824+(((-1.0)*py*x826)));
evalcond[1]=((((-1.0)*x827))+(((-1.0)*px*x826)));
evalcond[2]=(((cj2*py*x825))+(((-1.0)*cj2*x824))+((px*sj2*x825))+((sj2*x827)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x829 = IKatan2WithCheck(IkReal((((px*sj2))+((cj2*py)))),(((py*sj2))+(((-1.0)*(1.0)*cj2*px))),IKFAST_ATAN2_MAGTHRESH);
if(!x829.valid){
continue;
}
IkReal x828=((-1.0)*(x829.value));
j0array[0]=x828;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x828);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x830=IKsin(j0);
IkReal x831=(px*x830);
IkReal x832=IKcos(j0);
IkReal x833=((1.0)*x832);
IkReal x834=(py*x833);
IkReal x835=(py*x830);
evalcond[0]=(x831+(((-1.0)*x834)));
evalcond[1]=((((-1.0)*x835))+(((-1.0)*px*x833)));
evalcond[2]=(((sj2*x831))+((cj2*x835))+((cj2*px*x832))+(((-1.0)*sj2*x834)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x837 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*py)))),px,IKFAST_ATAN2_MAGTHRESH);
if(!x837.valid){
continue;
}
IkReal x836=((-1.0)*(x837.value));
j0array[0]=x836;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x836);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x838=IKcos(j0);
IkReal x839=(px*x838);
IkReal x840=IKsin(j0);
IkReal x841=(py*x840);
IkReal x842=(py*x838);
IkReal x843=(px*x840);
evalcond[0]=((((-1.0)*x839))+(((-1.0)*x841)));
evalcond[1]=((((-1.0)*cj2*x843))+((cj2*x842))+((sj2*x839))+((sj2*x841)));
evalcond[2]=(((cj2*x841))+(((-1.0)*sj2*x842))+((sj2*x843))+((cj2*x839)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x844=((-1.0)*(((1.0)*pp)));
IkReal x845=x753;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=((0.3364)+x844+(((0.336)*cj3)));
evalcond[2]=x845;
evalcond[3]=((-0.0164)+x844+(((-1.0)*(0.84)*pz)));
evalcond[4]=x845;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[4];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
IkReal x846=pz*pz;
j0eval[0]=(pp+(((-1.0)*x846)));
j0eval[1]=4.0;
j0eval[2]=sj3;
j0eval[3]=IKsign(((((-5.0)*x846))+(((5.0)*pp))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x847=((-1.0)*(((1.0)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=((0.6724)+x847);
evalcond[2]=((0.82)+pz);
evalcond[3]=((-0.0164)+x847+(((-1.0)*(0.84)*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=0;
cj3=1.0;
j3=0;
j0eval[0]=((IKabs(py))+(IKabs(px)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x849 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*py)))),px,IKFAST_ATAN2_MAGTHRESH);
if(!x849.valid){
continue;
}
IkReal x848=((-1.0)*(x849.value));
j0array[0]=x848;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x848);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*py*(IKsin(j0))))+(((-1.0)*(1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x850=((-1.0)*(((1.0)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=((0.0004)+x850);
evalcond[2]=((0.02)+pz);
evalcond[3]=((-0.0164)+x850+(((-1.0)*(0.84)*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=1.0;
cj2=0;
j2=1.5707963267949;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j0eval[0]=((IKabs(py))+(IKabs(px)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x852 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*py)))),px,IKFAST_ATAN2_MAGTHRESH);
if(!x852.valid){
continue;
}
IkReal x851=((-1.0)*(x852.value));
j0array[0]=x851;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x851);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*py*(IKsin(j0))))+(((-1.0)*(1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x853=((2.0)*sj3);
CheckValue<IkReal> x854=IKPowWithIntegerCheck(IKsign(((((-1.0)*(5.0)*(pz*pz)))+(((5.0)*pp)))),-1);
if(!x854.valid){
continue;
}
CheckValue<IkReal> x855 = IKatan2WithCheck(IkReal((px*x853)),((-1.0)*py*x853),IKFAST_ATAN2_MAGTHRESH);
if(!x855.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x854.value)))+(x855.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x856=((1.0)*(IKcos(j0)));
IkReal x857=IKsin(j0);
evalcond[0]=((((-1.0)*px*x856))+(((-1.0)*py*x857)));
evalcond[1]=((((-1.0)*py*x856))+(((-1.0)*(0.4)*sj3))+((px*x857)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x858=((-1.0)*(((1.0)*pp)));
IkReal x859=x753;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=((0.3364)+(((0.336)*cj3))+x858);
evalcond[2]=x859;
evalcond[3]=((-0.0164)+x858+(((-1.0)*(0.84)*pz)));
evalcond[4]=x859;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[4];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
IkReal x860=pz*pz;
j0eval[0]=(pp+(((-1.0)*x860)));
j0eval[1]=IKsign(((((-5.0)*x860))+(((5.0)*pp))));
j0eval[2]=4.0;
j0eval[3]=sj3;
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  || IKabs(j0eval[3]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x861=((-1.0)*(((1.0)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=((0.6724)+x861);
evalcond[2]=((0.82)+pz);
evalcond[3]=((-0.0164)+x861+(((-1.0)*(0.84)*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
sj3=0;
cj3=1.0;
j3=0;
j0eval[0]=((IKabs(py))+(IKabs(px)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x863 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*py)))),px,IKFAST_ATAN2_MAGTHRESH);
if(!x863.valid){
continue;
}
IkReal x862=((-1.0)*(x863.value));
j0array[0]=x862;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x862);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*py*(IKsin(j0))))+(((-1.0)*(1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x864=((-1.0)*(((1.0)*pp)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=((0.0004)+x864);
evalcond[2]=((0.02)+pz);
evalcond[3]=((-0.0164)+x864+(((-1.0)*(0.84)*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
j0eval[0]=((IKabs(py))+(IKabs(px)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x866 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*py)))),px,IKFAST_ATAN2_MAGTHRESH);
if(!x866.valid){
continue;
}
IkReal x865=((-1.0)*(x866.value));
j0array[0]=x865;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x865);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*py*(IKsin(j0))))+(((-1.0)*(1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x867=((2.0)*sj3);
CheckValue<IkReal> x868=IKPowWithIntegerCheck(IKsign(((((-1.0)*(5.0)*(pz*pz)))+(((5.0)*pp)))),-1);
if(!x868.valid){
continue;
}
CheckValue<IkReal> x869 = IKatan2WithCheck(IkReal(((-1.0)*px*x867)),(py*x867),IKFAST_ATAN2_MAGTHRESH);
if(!x869.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x868.value)))+(x869.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x870=((1.0)*(IKcos(j0)));
IkReal x871=IKsin(j0);
evalcond[0]=((((-1.0)*px*x870))+(((-1.0)*py*x871)));
evalcond[1]=((((-1.0)*py*x870))+(((0.4)*sj3))+((px*x871)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x872=((5.0)*sj2);
IkReal x873=((2.0)*sj3);
IkReal x874=(px*x873);
IkReal x875=(cj2*sj2);
IkReal x876=(py*x873);
IkReal x877=cj2*cj2;
CheckValue<IkReal> x878=IKPowWithIntegerCheck(IKsign(((((-1.0)*x872*(pz*pz)))+((pp*x872)))),-1);
if(!x878.valid){
continue;
}
CheckValue<IkReal> x879 = IKatan2WithCheck(IkReal((((x875*x876))+x874+(((-1.0)*x874*x877)))),((((-1.0)*x876))+((x876*x877))+((x874*x875))),IKFAST_ATAN2_MAGTHRESH);
if(!x879.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x878.value)))+(x879.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[4];
IkReal x880=IKsin(j0);
IkReal x881=(px*x880);
IkReal x882=((0.4)*sj3);
IkReal x883=IKcos(j0);
IkReal x884=((1.0)*x883);
IkReal x885=(py*x884);
IkReal x886=(py*x880);
IkReal x887=(cj2*x883);
evalcond[0]=((((-1.0)*x885))+(((-1.0)*sj2*x882))+x881);
evalcond[1]=(((cj2*x882))+(((-1.0)*x886))+(((-1.0)*px*x884)));
evalcond[2]=((((-1.0)*cj2*x881))+((sj2*x886))+((py*x887))+((px*sj2*x883)));
evalcond[3]=((((-1.0)*sj2*x885))+(((-1.0)*x882))+((px*x887))+((sj2*x881))+((cj2*x886)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x888=((5.0)*cj2);
IkReal x889=((2.0)*cj2*sj2*sj3);
IkReal x890=((2.0)*sj3*(cj2*cj2));
CheckValue<IkReal> x891=IKPowWithIntegerCheck(IKsign((((pp*x888))+(((-1.0)*x888*(pz*pz))))),-1);
if(!x891.valid){
continue;
}
CheckValue<IkReal> x892 = IKatan2WithCheck(IkReal((((py*x890))+((px*x889)))),(((px*x890))+(((-1.0)*py*x889))),IKFAST_ATAN2_MAGTHRESH);
if(!x892.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x891.value)))+(x892.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[4];
IkReal x893=IKsin(j0);
IkReal x894=(px*x893);
IkReal x895=((0.4)*sj3);
IkReal x896=IKcos(j0);
IkReal x897=((1.0)*x896);
IkReal x898=(py*x897);
IkReal x899=(py*x893);
IkReal x900=(cj2*x896);
evalcond[0]=((((-1.0)*x898))+(((-1.0)*sj2*x895))+x894);
evalcond[1]=((((-1.0)*px*x897))+((cj2*x895))+(((-1.0)*x899)));
evalcond[2]=((((-1.0)*cj2*x894))+((py*x900))+((px*sj2*x896))+((sj2*x899)));
evalcond[3]=(((sj2*x894))+(((-1.0)*x895))+((px*x900))+((cj2*x899))+(((-1.0)*sj2*x898)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x901=((2.0)*cj2*sj3);
IkReal x902=((2.0)*sj2*sj3);
CheckValue<IkReal> x903=IKPowWithIntegerCheck(IKsign(((((-1.0)*(5.0)*(pz*pz)))+(((5.0)*pp)))),-1);
if(!x903.valid){
continue;
}
CheckValue<IkReal> x904 = IKatan2WithCheck(IkReal((((px*x902))+((py*x901)))),((((-1.0)*py*x902))+((px*x901))),IKFAST_ATAN2_MAGTHRESH);
if(!x904.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x903.value)))+(x904.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[4];
IkReal x905=IKsin(j0);
IkReal x906=(px*x905);
IkReal x907=((0.4)*sj3);
IkReal x908=IKcos(j0);
IkReal x909=((1.0)*x908);
IkReal x910=(py*x909);
IkReal x911=(py*x905);
IkReal x912=(cj2*x908);
evalcond[0]=((((-1.0)*x910))+x906+(((-1.0)*sj2*x907)));
evalcond[1]=((((-1.0)*px*x909))+(((-1.0)*x911))+((cj2*x907)));
evalcond[2]=(((py*x912))+((sj2*x911))+(((-1.0)*cj2*x906))+((px*sj2*x908)));
evalcond[3]=(((px*x912))+(((-1.0)*sj2*x910))+((sj2*x906))+(((-1.0)*x907))+((cj2*x911)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x913=((0.42)*sj1);
IkReal x914=((0.4)*cj3*sj1);
IkReal x915=((0.4)*sj2*sj3);
IkReal x916=((0.4)*cj1*cj2*sj3);
CheckValue<IkReal> x917 = IKatan2WithCheck(IkReal((((py*x913))+(((-1.0)*py*x916))+((py*x914))+((px*x915)))),(((px*x913))+((px*x914))+(((-1.0)*px*x916))+(((-1.0)*py*x915))),IKFAST_ATAN2_MAGTHRESH);
if(!x917.valid){
continue;
}
CheckValue<IkReal> x918=IKPowWithIntegerCheck(IKsign((pp+(((-1.0)*(1.0)*(pz*pz))))),-1);
if(!x918.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x917.value)+(((1.5707963267949)*(x918.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[6];
IkReal x919=IKsin(j0);
IkReal x920=(px*x919);
IkReal x921=((0.4)*sj3);
IkReal x922=IKcos(j0);
IkReal x923=((1.0)*x922);
IkReal x924=(py*x923);
IkReal x925=(cj1*pz);
IkReal x926=((0.84)*sj1);
IkReal x927=(py*x919);
IkReal x928=((0.4)*cj3);
IkReal x929=(px*x923);
IkReal x930=((1.0)*x927);
IkReal x931=(cj1*cj2);
IkReal x932=(pz*sj1);
IkReal x933=(cj1*sj2);
evalcond[0]=((((-1.0)*x924))+(((-1.0)*sj2*x921))+x920);
evalcond[1]=((-0.0164)+(((0.84)*x925))+((px*x922*x926))+((x926*x927))+(((-1.0)*(1.0)*pp)));
evalcond[2]=((0.42)+(((-1.0)*x925))+(((-1.0)*sj1*x929))+(((-1.0)*sj1*x930))+x928);
evalcond[3]=((((-1.0)*x930))+(((-1.0)*x921*x931))+(((0.42)*sj1))+(((-1.0)*x929))+((sj1*x928)));
evalcond[4]=((((-1.0)*cj2*x920))+(((-1.0)*x930*x933))+((cj2*py*x922))+((sj2*x932))+(((-1.0)*x929*x933)));
evalcond[5]=(((cj2*x932))+((sj2*x920))+(((-1.0)*x921))+(((-1.0)*x929*x931))+(((-1.0)*sj2*x924))+(((-1.0)*x930*x931)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x934=((105.0)*sj1);
IkReal x935=((125.0)*pp);
IkReal x936=((105.0)*cj1*pz);
IkReal x937=((42.0)*sj1*sj2*sj3);
CheckValue<IkReal> x938=IKPowWithIntegerCheck(IKsign(((((-1.0)*x934*(pz*pz)))+((pp*x934)))),-1);
if(!x938.valid){
continue;
}
CheckValue<IkReal> x939 = IKatan2WithCheck(IkReal((((px*x937))+(((-1.0)*py*x936))+((py*x935))+(((2.05)*py)))),(((px*x935))+(((-1.0)*py*x937))+(((-1.0)*px*x936))+(((2.05)*px))),IKFAST_ATAN2_MAGTHRESH);
if(!x939.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x938.value)))+(x939.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[6];
IkReal x940=IKsin(j0);
IkReal x941=(px*x940);
IkReal x942=((0.4)*sj3);
IkReal x943=IKcos(j0);
IkReal x944=((1.0)*x943);
IkReal x945=(py*x944);
IkReal x946=(cj1*pz);
IkReal x947=((0.84)*sj1);
IkReal x948=(py*x940);
IkReal x949=((0.4)*cj3);
IkReal x950=(px*x944);
IkReal x951=((1.0)*x948);
IkReal x952=(cj1*cj2);
IkReal x953=(pz*sj1);
IkReal x954=(cj1*sj2);
evalcond[0]=((((-1.0)*sj2*x942))+(((-1.0)*x945))+x941);
evalcond[1]=((-0.0164)+(((0.84)*x946))+((x947*x948))+((px*x943*x947))+(((-1.0)*(1.0)*pp)));
evalcond[2]=((0.42)+(((-1.0)*x946))+(((-1.0)*sj1*x950))+x949+(((-1.0)*sj1*x951)));
evalcond[3]=((((-1.0)*x942*x952))+(((-1.0)*x951))+(((-1.0)*x950))+((sj1*x949))+(((0.42)*sj1)));
evalcond[4]=((((-1.0)*cj2*x941))+(((-1.0)*x951*x954))+(((-1.0)*x950*x954))+((sj2*x953))+((cj2*py*x943)));
evalcond[5]=((((-1.0)*x942))+(((-1.0)*x951*x952))+(((-1.0)*x950*x952))+((cj2*x953))+(((-1.0)*sj2*x945))+((sj2*x941)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x955=((0.4)*cj3);
IkReal x956=((1.0)*cj1*pz);
IkReal x957=((0.4)*sj1*sj2*sj3);
CheckValue<IkReal> x958 = IKatan2WithCheck(IkReal((((px*x957))+((py*x955))+(((-1.0)*py*x956))+(((0.42)*py)))),(((px*x955))+(((-1.0)*py*x957))+(((-1.0)*px*x956))+(((0.42)*px))),IKFAST_ATAN2_MAGTHRESH);
if(!x958.valid){
continue;
}
CheckValue<IkReal> x959=IKPowWithIntegerCheck(IKsign(((((-1.0)*(1.0)*sj1*(pz*pz)))+((pp*sj1)))),-1);
if(!x959.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x958.value)+(((1.5707963267949)*(x959.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[6];
IkReal x960=IKsin(j0);
IkReal x961=(px*x960);
IkReal x962=((0.4)*sj3);
IkReal x963=IKcos(j0);
IkReal x964=((1.0)*x963);
IkReal x965=(py*x964);
IkReal x966=(cj1*pz);
IkReal x967=((0.84)*sj1);
IkReal x968=(py*x960);
IkReal x969=((0.4)*cj3);
IkReal x970=(px*x964);
IkReal x971=((1.0)*x968);
IkReal x972=(cj1*cj2);
IkReal x973=(pz*sj1);
IkReal x974=(cj1*sj2);
evalcond[0]=((((-1.0)*sj2*x962))+(((-1.0)*x965))+x961);
evalcond[1]=((-0.0164)+((x967*x968))+(((0.84)*x966))+((px*x963*x967))+(((-1.0)*(1.0)*pp)));
evalcond[2]=((0.42)+(((-1.0)*sj1*x970))+(((-1.0)*sj1*x971))+(((-1.0)*x966))+x969);
evalcond[3]=((((-1.0)*x962*x972))+((sj1*x969))+(((0.42)*sj1))+(((-1.0)*x970))+(((-1.0)*x971)));
evalcond[4]=((((-1.0)*x971*x974))+(((-1.0)*x970*x974))+((sj2*x973))+(((-1.0)*cj2*x961))+((cj2*py*x963)));
evalcond[5]=(((sj2*x961))+((cj2*x973))+(((-1.0)*x971*x972))+(((-1.0)*x970*x972))+(((-1.0)*x962))+(((-1.0)*sj2*x965)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x977 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*py)))),px,IKFAST_ATAN2_MAGTHRESH);
if(!x977.valid){
continue;
}
IkReal x975=((-1.0)*(x977.value));
if((((py*py)+(px*px))) < -0.00001)
continue;
CheckValue<IkReal> x978=IKPowWithIntegerCheck(IKabs(IKsqrt(((py*py)+(px*px)))),-1);
if(!x978.valid){
continue;
}
if( (((0.4)*sj2*sj3*(x978.value))) < -1-IKFAST_SINCOS_THRESH || (((0.4)*sj2*sj3*(x978.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x976=IKasin(((0.4)*sj2*sj3*(x978.value)));
j0array[0]=(x976+x975);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x976))+x975);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break;
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j1eval[3];
IkReal x979=(cj0*px);
IkReal x980=(py*sj0);
IkReal x981=(cj2*sj3);
IkReal x982=(pz*x981);
IkReal x983=(cj0*cj3*px);
IkReal x984=(cj3*py*sj0);
IkReal x985=((5.0)*pz);
j1eval[0]=((((-1.05)*x979))+(((-1.0)*x983))+(((-1.05)*x980))+x982+(((-1.0)*x984)));
j1eval[1]=((IKabs(((((0.8)*cj3*x981))+(((0.84)*x981))+(((-1.0)*x980*x985))+(((-1.0)*x979*x985)))))+(IKabs(((-0.882)+(((5.0)*(pz*pz)))+(((-1.0)*(0.8)*(cj3*cj3)))+(((-1.0)*(1.68)*cj3))))));
j1eval[2]=IKsign(((((2.0)*x982))+(((-2.1)*x980))+(((-2.0)*x984))+(((-2.1)*x979))+(((-2.0)*x983))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
IkReal x986=(cj0*px);
IkReal x987=(py*sj0);
IkReal x988=(cj2*sj3);
IkReal x989=(pz*x988);
IkReal x990=(cj0*cj3*px);
IkReal x991=(cj3*py*sj0);
IkReal x992=((50.0)*pp);
IkReal x993=((105.0)*pz);
j1eval[0]=((((-1.0)*x990))+(((-1.05)*x987))+(((-1.05)*x986))+x989+(((-1.0)*x991)));
j1eval[1]=IKsign(((((-42.0)*x990))+(((-42.0)*x991))+(((-44.1)*x987))+(((-44.1)*x986))+(((42.0)*x989))));
j1eval[2]=((IKabs((((x988*x992))+(((-1.0)*x987*x993))+(((0.82)*x988))+(((-1.0)*x986*x993)))))+(IKabs(((-0.861)+(((-1.0)*(0.82)*cj3))+(((105.0)*(pz*pz)))+(((-1.0)*(52.5)*pp))+(((-1.0)*cj3*x992))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
IkReal x994=cj2*cj2;
IkReal x995=cj3*cj3;
IkReal x996=((4.0)*x994);
IkReal x997=((10.0)*cj3);
IkReal x998=(cj0*px);
IkReal x999=((10.0)*cj2*sj3);
IkReal x1000=(py*sj0);
j1eval[0]=((1.1025)+(((2.1)*cj3))+(((-1.0)*x994*x995))+x995+x994);
j1eval[1]=IKsign(((4.41)+(((4.0)*x995))+(((-1.0)*x995*x996))+x996+(((8.4)*cj3))));
j1eval[2]=((IKabs(((((10.5)*pz))+(((-1.0)*x998*x999))+((pz*x997))+(((-1.0)*x1000*x999)))))+(IKabs(((((10.5)*x998))+((x1000*x997))+((x997*x998))+((pz*x999))+(((10.5)*x1000))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1001=((4.0)*(cj2*cj2));
IkReal x1002=cj3*cj3;
IkReal x1003=(cj0*px);
IkReal x1004=(py*sj0);
IkReal x1005=((10.0)*cj3);
IkReal x1006=((10.0)*cj2*sj3);
CheckValue<IkReal> x1007 = IKatan2WithCheck(IkReal((((x1003*x1005))+(((10.5)*x1003))+((x1004*x1005))+((pz*x1006))+(((10.5)*x1004)))),((((10.5)*pz))+(((-1.0)*x1003*x1006))+(((-1.0)*x1004*x1006))+((pz*x1005))),IKFAST_ATAN2_MAGTHRESH);
if(!x1007.valid){
continue;
}
CheckValue<IkReal> x1008=IKPowWithIntegerCheck(IKsign(((4.41)+(((4.0)*x1002))+x1001+(((-1.0)*x1001*x1002))+(((8.4)*cj3)))),-1);
if(!x1008.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1007.value)+(((1.5707963267949)*(x1008.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break;
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x1009=IKcos(j1);
IkReal x1010=((0.4)*cj3);
IkReal x1011=IKsin(j1);
IkReal x1012=((0.4)*cj2*sj3);
IkReal x1013=(pz*x1009);
IkReal x1014=((0.84)*x1011);
IkReal x1015=((1.0)*cj0);
IkReal x1016=(px*x1015);
IkReal x1017=((1.0)*sj0);
IkReal x1018=(py*x1017);
IkReal x1019=(pz*x1011);
IkReal x1020=((1.0)*cj0*px*x1009);
IkReal x1021=((1.0)*py*sj0*x1009);
evalcond[0]=((((-0.42)*x1009))+pz+(((-1.0)*x1011*x1012))+(((-1.0)*x1009*x1010)));
evalcond[1]=((-0.0164)+((py*sj0*x1014))+((cj0*px*x1014))+(((-1.0)*(1.0)*pp))+(((0.84)*x1013)));
evalcond[2]=((0.42)+(((-1.0)*x1011*x1018))+x1010+(((-1.0)*x1013))+(((-1.0)*x1011*x1016)));
evalcond[3]=((((-1.0)*x1009*x1012))+((x1010*x1011))+(((-1.0)*x1016))+(((-1.0)*x1018))+(((0.42)*x1011)));
evalcond[4]=((((-1.0)*cj2*px*x1017))+((sj2*x1019))+(((-1.0)*sj2*x1020))+(((-1.0)*sj2*x1021))+((cj0*cj2*py)));
evalcond[5]=((((-1.0)*cj2*x1021))+(((-1.0)*py*sj2*x1015))+(((-1.0)*(0.4)*sj3))+((px*sj0*sj2))+(((-1.0)*cj2*x1020))+((cj2*x1019)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1022=(cj0*px);
IkReal x1023=(py*sj0);
IkReal x1024=((42.0)*cj3);
IkReal x1025=(cj2*sj3);
IkReal x1026=((50.0)*pp);
IkReal x1027=((105.0)*pz);
CheckValue<IkReal> x1028=IKPowWithIntegerCheck(IKsign(((((42.0)*pz*x1025))+(((-1.0)*x1023*x1024))+(((-1.0)*x1022*x1024))+(((-44.1)*x1022))+(((-44.1)*x1023)))),-1);
if(!x1028.valid){
continue;
}
CheckValue<IkReal> x1029 = IKatan2WithCheck(IkReal(((-0.861)+(((-1.0)*cj3*x1026))+(((-1.0)*(0.82)*cj3))+(((105.0)*(pz*pz)))+(((-1.0)*(52.5)*pp)))),((((-1.0)*x1022*x1027))+((x1025*x1026))+(((0.82)*x1025))+(((-1.0)*x1023*x1027))),IKFAST_ATAN2_MAGTHRESH);
if(!x1029.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1028.value)))+(x1029.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break;
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x1030=IKcos(j1);
IkReal x1031=((0.4)*cj3);
IkReal x1032=IKsin(j1);
IkReal x1033=((0.4)*cj2*sj3);
IkReal x1034=(pz*x1030);
IkReal x1035=((0.84)*x1032);
IkReal x1036=((1.0)*cj0);
IkReal x1037=(px*x1036);
IkReal x1038=((1.0)*sj0);
IkReal x1039=(py*x1038);
IkReal x1040=(pz*x1032);
IkReal x1041=((1.0)*cj0*px*x1030);
IkReal x1042=((1.0)*py*sj0*x1030);
evalcond[0]=((((-1.0)*x1032*x1033))+pz+(((-1.0)*x1030*x1031))+(((-0.42)*x1030)));
evalcond[1]=((-0.0164)+((py*sj0*x1035))+((cj0*px*x1035))+(((0.84)*x1034))+(((-1.0)*(1.0)*pp)));
evalcond[2]=((0.42)+(((-1.0)*x1034))+(((-1.0)*x1032*x1039))+x1031+(((-1.0)*x1032*x1037)));
evalcond[3]=((((-1.0)*x1039))+((x1031*x1032))+(((0.42)*x1032))+(((-1.0)*x1030*x1033))+(((-1.0)*x1037)));
evalcond[4]=((((-1.0)*sj2*x1042))+(((-1.0)*sj2*x1041))+(((-1.0)*cj2*px*x1038))+((sj2*x1040))+((cj0*cj2*py)));
evalcond[5]=((((-1.0)*py*sj2*x1036))+(((-1.0)*cj2*x1041))+(((-1.0)*cj2*x1042))+((cj2*x1040))+(((-1.0)*(0.4)*sj3))+((px*sj0*sj2)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1043=(cj0*px);
IkReal x1044=(py*sj0);
IkReal x1045=((2.0)*cj3);
IkReal x1046=(cj2*sj3);
IkReal x1047=((5.0)*pz);
CheckValue<IkReal> x1048=IKPowWithIntegerCheck(IKsign(((((-2.1)*x1044))+(((-2.1)*x1043))+(((2.0)*pz*x1046))+(((-1.0)*x1043*x1045))+(((-1.0)*x1044*x1045)))),-1);
if(!x1048.valid){
continue;
}
CheckValue<IkReal> x1049 = IKatan2WithCheck(IkReal(((-0.882)+(((5.0)*(pz*pz)))+(((-1.0)*(0.8)*(cj3*cj3)))+(((-1.0)*(1.68)*cj3)))),((((-1.0)*x1043*x1047))+(((0.8)*cj3*x1046))+(((-1.0)*x1044*x1047))+(((0.84)*x1046))),IKFAST_ATAN2_MAGTHRESH);
if(!x1049.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1048.value)))+(x1049.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break;
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x1050=IKcos(j1);
IkReal x1051=((0.4)*cj3);
IkReal x1052=IKsin(j1);
IkReal x1053=((0.4)*cj2*sj3);
IkReal x1054=(pz*x1050);
IkReal x1055=((0.84)*x1052);
IkReal x1056=((1.0)*cj0);
IkReal x1057=(px*x1056);
IkReal x1058=((1.0)*sj0);
IkReal x1059=(py*x1058);
IkReal x1060=(pz*x1052);
IkReal x1061=((1.0)*cj0*px*x1050);
IkReal x1062=((1.0)*py*sj0*x1050);
evalcond[0]=((((-0.42)*x1050))+(((-1.0)*x1050*x1051))+pz+(((-1.0)*x1052*x1053)));
evalcond[1]=((-0.0164)+((cj0*px*x1055))+(((0.84)*x1054))+((py*sj0*x1055))+(((-1.0)*(1.0)*pp)));
evalcond[2]=((0.42)+(((-1.0)*x1052*x1059))+(((-1.0)*x1054))+(((-1.0)*x1052*x1057))+x1051);
evalcond[3]=((((0.42)*x1052))+((x1051*x1052))+(((-1.0)*x1050*x1053))+(((-1.0)*x1057))+(((-1.0)*x1059)));
evalcond[4]=(((sj2*x1060))+(((-1.0)*sj2*x1062))+(((-1.0)*cj2*px*x1058))+(((-1.0)*sj2*x1061))+((cj0*cj2*py)));
evalcond[5]=((((-1.0)*cj2*x1062))+(((-1.0)*cj2*x1061))+((cj2*x1060))+(((-1.0)*(0.4)*sj3))+((px*sj0*sj2))+(((-1.0)*py*sj2*x1056)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
}
}
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x135=(cj1*sj3);
IkReal x136=((1.0)*cj2);
IkReal x137=(cj3*sj1);
IkReal x138=(x135+(((-1.0)*x136*x137)));
IkReal x139=(sj1*sj3);
IkReal x140=(cj1*cj3);
IkReal x141=(x139+((cj2*x140)));
IkReal x142=(((sj0*x141))+((cj3*((cj0*sj2)))));
IkReal x143=((1.0)*sj0*sj2);
IkReal x144=((((-1.0)*cj3*x143))+((cj0*x141)));
IkReal x145=(sj1*sj2);
IkReal x146=((((-1.0)*cj1*x143))+((cj0*cj2)));
IkReal x147=((1.0)*cj0*sj2);
IkReal x148=((((-1.0)*sj0*x136))+(((-1.0)*cj1*x147)));
IkReal x149=(x140+((cj2*x139)));
IkReal x150=(x137+(((-1.0)*x135*x136)));
IkReal x151=(((cj0*x150))+((sj3*((sj0*sj2)))));
IkReal x152=(((sj0*x150))+(((-1.0)*sj3*x147)));
new_r00=(((r10*x142))+((r00*x144))+((r20*x138)));
new_r01=(((r11*x142))+((r21*x138))+((r01*x144)));
new_r02=(((r02*x144))+((r22*x138))+((r12*x142)));
new_r10=(((r10*x146))+((r20*x145))+((r00*x148)));
new_r11=(((r11*x146))+((r21*x145))+((r01*x148)));
new_r12=(((r12*x146))+((r22*x145))+((r02*x148)));
new_r20=(((r20*x149))+((r00*x151))+((r10*x152)));
new_r21=(((r01*x151))+((r11*x152))+((r21*x149)));
new_r22=(((r02*x151))+((r12*x152))+((r22*x149)));
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
cj5array[0]=new_r22;
if( cj5array[0] >= -1-IKFAST_SINCOS_THRESH && cj5array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j5valid[0] = j5valid[1] = true;
    j5array[0] = IKacos(cj5array[0]);
    sj5array[0] = IKsin(j5array[0]);
    cj5array[1] = cj5array[0];
    j5array[1] = -j5array[0];
    sj5array[1] = -sj5array[0];
}
else if( std::isnan(cj5array[0]) )
{
    // probably any value will work
    j5valid[0] = true;
    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
}
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break;
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j4eval[2];
IkReal x153=(cj1*sj3);
IkReal x154=((1.0)*cj2);
IkReal x155=(cj3*sj1);
IkReal x156=(x153+(((-1.0)*x154*x155)));
IkReal x157=(sj1*sj3);
IkReal x158=(cj1*cj3);
IkReal x159=(x157+((cj2*x158)));
IkReal x160=(((sj0*x159))+((cj3*((cj0*sj2)))));
IkReal x161=((1.0)*sj0*sj2);
IkReal x162=((((-1.0)*cj3*x161))+((cj0*x159)));
IkReal x163=(sj1*sj2);
IkReal x164=x146;
IkReal x165=((1.0)*cj0*sj2);
IkReal x166=x148;
IkReal x167=(x158+((cj2*x157)));
IkReal x168=(x155+(((-1.0)*x153*x154)));
IkReal x169=(((cj0*x168))+((sj3*((sj0*sj2)))));
IkReal x170=(((sj0*x168))+(((-1.0)*sj3*x165)));
new_r00=(((r20*x156))+((r10*x160))+((r00*x162)));
new_r01=(((r21*x156))+((r11*x160))+((r01*x162)));
new_r02=(((r02*x162))+((r12*x160))+((r22*x156)));
new_r10=(((r10*x164))+((r20*x163))+((r00*x166)));
new_r11=(((r11*x164))+((r01*x166))+((r21*x163)));
new_r12=(((r12*x164))+((r22*x163))+((r02*x166)));
new_r20=(((r00*x169))+((r10*x170))+((r20*x167)));
new_r21=(((r21*x167))+((r01*x169))+((r11*x170)));
new_r22=(((r02*x169))+((r12*x170))+((r22*x167)));
j4eval[0]=sj5;
j4eval[1]=IKsign(sj5);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x171=(cj1*sj3);
IkReal x172=((1.0)*cj2);
IkReal x173=(cj3*sj1);
IkReal x174=((((-1.0)*x172*x173))+x171);
IkReal x175=(sj1*sj3);
IkReal x176=(cj1*cj3);
IkReal x177=(((cj2*x176))+x175);
IkReal x178=(((sj0*x177))+((cj3*((cj0*sj2)))));
IkReal x179=((1.0)*sj0*sj2);
IkReal x180=((((-1.0)*cj3*x179))+((cj0*x177)));
IkReal x181=(sj1*sj2);
IkReal x182=x146;
IkReal x183=((1.0)*cj0*sj2);
IkReal x184=x148;
IkReal x185=(((cj2*x175))+x176);
IkReal x186=(x173+(((-1.0)*x171*x172)));
IkReal x187=(((cj0*x186))+((sj3*((sj0*sj2)))));
IkReal x188=(((sj0*x186))+(((-1.0)*sj3*x183)));
new_r00=(((r20*x174))+((r10*x178))+((r00*x180)));
new_r01=(((r11*x178))+((r21*x174))+((r01*x180)));
new_r02=(((r02*x180))+((r22*x174))+((r12*x178)));
new_r10=(((r20*x181))+((r00*x184))+((r10*x182)));
new_r11=(((r11*x182))+((r01*x184))+((r21*x181)));
new_r12=(((r12*x182))+((r02*x184))+((r22*x181)));
new_r20=(((r10*x188))+((r20*x185))+((r00*x187)));
new_r21=(((r21*x185))+((r01*x187))+((r11*x188)));
new_r22=(((r22*x185))+((r12*x188))+((r02*x187)));
j4eval[0]=sj5;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[6];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r21;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r20;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x190 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x190.valid){
continue;
}
IkReal x189=((-1.0)*(((1.0)*(x190.value))));
j4array[0]=x189;
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+x189);
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break;
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*new_r02*(IKsin(j4))))+((new_r12*(IKcos(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x191=((1.0)*cj4);
if( IKabs((((new_r00*sj4))+(((-1.0)*new_r10*x191)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r00*x191))+(((-1.0)*(1.0)*new_r10*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*sj4))+(((-1.0)*new_r10*x191))))+IKsqr(((((-1.0)*new_r00*x191))+(((-1.0)*(1.0)*new_r10*sj4))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((((new_r00*sj4))+(((-1.0)*new_r10*x191))), ((((-1.0)*new_r00*x191))+(((-1.0)*(1.0)*new_r10*sj4))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x192=IKcos(j6);
IkReal x193=IKsin(j6);
IkReal x194=((1.0)*sj4);
IkReal x195=(cj4*x193);
IkReal x196=((((-1.0)*x193*x194))+((cj4*x192)));
evalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x192);
evalcond[1]=(((cj4*new_r10))+x193+(((-1.0)*new_r00*x194)));
evalcond[2]=(((cj4*new_r11))+(((-1.0)*new_r01*x194))+x192);
evalcond[3]=(new_r10+((sj4*x192))+x195);
evalcond[4]=(((cj4*new_r01))+(((-1.0)*x193))+((new_r11*sj4)));
evalcond[5]=(new_r00+x196);
evalcond[6]=(new_r11+x196);
evalcond[7]=((((-1.0)*x192*x194))+new_r01+(((-1.0)*x195)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r21;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r20;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x198 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x198.valid){
continue;
}
IkReal x197=((-1.0)*(((1.0)*(x198.value))));
j4array[0]=x197;
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+x197);
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break;
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*new_r02*(IKsin(j4))))+((new_r12*(IKcos(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x199=((1.0)*cj4);
if( IKabs(((((-1.0)*(1.0)*new_r11*sj4))+(((-1.0)*new_r10*x199)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r11*x199))+((new_r10*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*(1.0)*new_r11*sj4))+(((-1.0)*new_r10*x199))))+IKsqr(((((-1.0)*new_r11*x199))+((new_r10*sj4))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*(1.0)*new_r11*sj4))+(((-1.0)*new_r10*x199))), ((((-1.0)*new_r11*x199))+((new_r10*sj4))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x200=IKsin(j6);
IkReal x201=((1.0)*sj4);
IkReal x202=IKcos(j6);
IkReal x203=(cj4*x202);
IkReal x204=(((cj4*x200))+(((-1.0)*x201*x202)));
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x200);
evalcond[1]=(((cj4*new_r10))+x200+(((-1.0)*new_r00*x201)));
evalcond[2]=(((cj4*new_r11))+x202+(((-1.0)*new_r01*x201)));
evalcond[3]=((((-1.0)*x202))+((cj4*new_r00))+((new_r10*sj4)));
evalcond[4]=(((sj4*x200))+new_r11+x203);
evalcond[5]=(new_r10+x204);
evalcond[6]=(x204+new_r01);
evalcond[7]=((((-1.0)*x203))+(((-1.0)*x200*x201))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x206=IKPowWithIntegerCheck(sj5,-1);
if(!x206.valid){
continue;
}
IkReal x205=x206.value;
CheckValue<IkReal> x207=IKPowWithIntegerCheck(new_r12,-1);
if(!x207.valid){
continue;
}
if( IKabs((x205*(x207.value)*(((1.0)+(((-1.0)*(1.0)*(new_r02*new_r02)))+(((-1.0)*(1.0)*(cj5*cj5))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x205)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x205*(x207.value)*(((1.0)+(((-1.0)*(1.0)*(new_r02*new_r02)))+(((-1.0)*(1.0)*(cj5*cj5)))))))+IKsqr((new_r02*x205))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x205*(x207.value)*(((1.0)+(((-1.0)*(1.0)*(new_r02*new_r02)))+(((-1.0)*(1.0)*(cj5*cj5)))))), (new_r02*x205));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break;
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x208=IKcos(j4);
IkReal x209=((1.0)*sj5);
IkReal x210=IKsin(j4);
IkReal x211=(new_r02*x208);
IkReal x212=(new_r12*x210);
IkReal x213=(sj5*x208);
IkReal x214=(sj5*x210);
IkReal x215=((1.0)*cj5);
evalcond[0]=(new_r02+(((-1.0)*x208*x209)));
evalcond[1]=((((-1.0)*x209*x210))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x210))+((new_r12*x208)));
evalcond[3]=((((-1.0)*x209))+x211+x212);
evalcond[4]=(((new_r10*x214))+((cj5*new_r20))+((new_r00*x213)));
evalcond[5]=(((new_r11*x214))+((cj5*new_r21))+((new_r01*x213)));
evalcond[6]=((-1.0)+((sj5*x212))+((cj5*new_r22))+((sj5*x211)));
evalcond[7]=((((-1.0)*x212*x215))+((new_r22*sj5))+(((-1.0)*x211*x215)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6eval[2];
IkReal x216=(cj1*sj3);
IkReal x217=((1.0)*cj2);
IkReal x218=(cj3*sj1);
IkReal x219=(x216+(((-1.0)*x217*x218)));
IkReal x220=(sj1*sj3);
IkReal x221=(cj1*cj3);
IkReal x222=(x220+((cj2*x221)));
IkReal x223=(((cj3*((cj0*sj2))))+((sj0*x222)));
IkReal x224=((1.0)*sj0*sj2);
IkReal x225=(((cj0*x222))+(((-1.0)*cj3*x224)));
IkReal x226=(sj1*sj2);
IkReal x227=x146;
IkReal x228=((1.0)*cj0*sj2);
IkReal x229=x148;
IkReal x230=(((cj2*x220))+x221);
IkReal x231=(x218+(((-1.0)*x216*x217)));
IkReal x232=(((cj0*x231))+((sj3*((sj0*sj2)))));
IkReal x233=((((-1.0)*sj3*x228))+((sj0*x231)));
new_r00=(((r10*x223))+((r20*x219))+((r00*x225)));
new_r01=(((r01*x225))+((r21*x219))+((r11*x223)));
new_r02=(((r22*x219))+((r12*x223))+((r02*x225)));
new_r10=(((r00*x229))+((r20*x226))+((r10*x227)));
new_r11=(((r01*x229))+((r11*x227))+((r21*x226)));
new_r12=(((r12*x227))+((r22*x226))+((r02*x229)));
new_r20=(((r20*x230))+((r10*x233))+((r00*x232)));
new_r21=(((r21*x230))+((r11*x233))+((r01*x232)));
new_r22=(((r22*x230))+((r12*x233))+((r02*x232)));
j6eval[0]=sj5;
j6eval[1]=IKsign(sj5);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
IkReal x234=(cj1*sj3);
IkReal x235=((1.0)*cj2);
IkReal x236=(cj3*sj1);
IkReal x237=((((-1.0)*x235*x236))+x234);
IkReal x238=(sj1*sj3);
IkReal x239=(cj1*cj3);
IkReal x240=(((cj2*x239))+x238);
IkReal x241=(((sj0*x240))+((cj3*((cj0*sj2)))));
IkReal x242=((1.0)*sj0*sj2);
IkReal x243=((((-1.0)*cj3*x242))+((cj0*x240)));
IkReal x244=(sj1*sj2);
IkReal x245=x146;
IkReal x246=((1.0)*cj0*sj2);
IkReal x247=x148;
IkReal x248=(((cj2*x238))+x239);
IkReal x249=((((-1.0)*x234*x235))+x236);
IkReal x250=(((cj0*x249))+((sj3*((sj0*sj2)))));
IkReal x251=(((sj0*x249))+(((-1.0)*sj3*x246)));
new_r00=(((r20*x237))+((r00*x243))+((r10*x241)));
new_r01=(((r21*x237))+((r11*x241))+((r01*x243)));
new_r02=(((r22*x237))+((r02*x243))+((r12*x241)));
new_r10=(((r20*x244))+((r00*x247))+((r10*x245)));
new_r11=(((r11*x245))+((r01*x247))+((r21*x244)));
new_r12=(((r22*x244))+((r12*x245))+((r02*x247)));
new_r20=(((r10*x251))+((r20*x248))+((r00*x250)));
new_r21=(((r11*x251))+((r21*x248))+((r01*x250)));
new_r22=(((r12*x251))+((r02*x250))+((r22*x248)));
j6eval[0]=sj5;
j6eval[1]=cj4;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
IkReal x252=(cj1*sj3);
IkReal x253=((1.0)*cj2);
IkReal x254=(cj3*sj1);
IkReal x255=(x252+(((-1.0)*x253*x254)));
IkReal x256=(sj1*sj3);
IkReal x257=(cj1*cj3);
IkReal x258=(((cj2*x257))+x256);
IkReal x259=(((sj0*x258))+((cj3*((cj0*sj2)))));
IkReal x260=((1.0)*sj0*sj2);
IkReal x261=((((-1.0)*cj3*x260))+((cj0*x258)));
IkReal x262=(sj1*sj2);
IkReal x263=x146;
IkReal x264=((1.0)*cj0*sj2);
IkReal x265=x148;
IkReal x266=(x257+((cj2*x256)));
IkReal x267=((((-1.0)*x252*x253))+x254);
IkReal x268=(((cj0*x267))+((sj3*((sj0*sj2)))));
IkReal x269=(((sj0*x267))+(((-1.0)*sj3*x264)));
new_r00=(((r00*x261))+((r10*x259))+((r20*x255)));
new_r01=(((r21*x255))+((r11*x259))+((r01*x261)));
new_r02=(((r22*x255))+((r12*x259))+((r02*x261)));
new_r10=(((r00*x265))+((r20*x262))+((r10*x263)));
new_r11=(((r11*x263))+((r21*x262))+((r01*x265)));
new_r12=(((r02*x265))+((r22*x262))+((r12*x263)));
new_r20=(((r10*x269))+((r00*x268))+((r20*x266)));
new_r21=(((r01*x268))+((r21*x266))+((r11*x269)));
new_r22=(((r02*x268))+((r22*x266))+((r12*x269)));
j6eval[0]=sj5;
j6eval[1]=cj5;
j6eval[2]=sj4;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x270=((((-1.0)*(1.0)*new_r02*sj4))+((cj4*new_r12)));
IkReal x271=(cj4*new_r02);
IkReal x272=(new_r12*sj4);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r21;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r20;
evalcond[6]=x270;
evalcond[7]=x270;
evalcond[8]=(x272+x271);
evalcond[9]=((((-1.0)*x272))+(((-1.0)*x271)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x273=((1.0)*cj4);
if( IKabs((((new_r00*sj4))+(((-1.0)*new_r10*x273)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*(1.0)*new_r10*sj4))+(((-1.0)*new_r00*x273)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*sj4))+(((-1.0)*new_r10*x273))))+IKsqr(((((-1.0)*(1.0)*new_r10*sj4))+(((-1.0)*new_r00*x273))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((((new_r00*sj4))+(((-1.0)*new_r10*x273))), ((((-1.0)*(1.0)*new_r10*sj4))+(((-1.0)*new_r00*x273))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x274=IKcos(j6);
IkReal x275=IKsin(j6);
IkReal x276=((1.0)*sj4);
IkReal x277=(cj4*x275);
IkReal x278=((((-1.0)*x275*x276))+((cj4*x274)));
evalcond[0]=(x274+((cj4*new_r00))+((new_r10*sj4)));
evalcond[1]=(((cj4*new_r10))+(((-1.0)*new_r00*x276))+x275);
evalcond[2]=((((-1.0)*new_r01*x276))+x274+((cj4*new_r11)));
evalcond[3]=(x277+((sj4*x274))+new_r10);
evalcond[4]=((((-1.0)*x275))+((cj4*new_r01))+((new_r11*sj4)));
evalcond[5]=(x278+new_r00);
evalcond[6]=(x278+new_r11);
evalcond[7]=((((-1.0)*x274*x276))+new_r01+(((-1.0)*x277)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x279=((((-1.0)*(1.0)*new_r02*sj4))+((cj4*new_r12)));
IkReal x280=(((cj4*new_r02))+((new_r12*sj4)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r21;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r20;
evalcond[6]=x279;
evalcond[7]=x279;
evalcond[8]=x280;
evalcond[9]=x280;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x281=((1.0)*cj4);
if( IKabs(((((-1.0)*(1.0)*new_r11*sj4))+(((-1.0)*new_r10*x281)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r11*x281))+((new_r10*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*(1.0)*new_r11*sj4))+(((-1.0)*new_r10*x281))))+IKsqr(((((-1.0)*new_r11*x281))+((new_r10*sj4))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*(1.0)*new_r11*sj4))+(((-1.0)*new_r10*x281))), ((((-1.0)*new_r11*x281))+((new_r10*sj4))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x282=IKsin(j6);
IkReal x283=((1.0)*sj4);
IkReal x284=IKcos(j6);
IkReal x285=(cj4*x284);
IkReal x286=((((-1.0)*x283*x284))+((cj4*x282)));
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x282);
evalcond[1]=(((cj4*new_r10))+(((-1.0)*new_r00*x283))+x282);
evalcond[2]=((((-1.0)*new_r01*x283))+((cj4*new_r11))+x284);
evalcond[3]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x284)));
evalcond[4]=(((sj4*x282))+new_r11+x285);
evalcond[5]=(new_r10+x286);
evalcond[6]=(new_r01+x286);
evalcond[7]=((((-1.0)*x282*x283))+new_r00+(((-1.0)*x285)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x287=((1.0)*sj4);
IkReal x288=(((cj4*new_r12))+(((-1.0)*new_r02*x287)));
IkReal x289=((-1.0)+((cj4*new_r02))+((new_r12*sj4)));
IkReal x290=(((cj4*new_r00))+((new_r10*sj4)));
IkReal x291=(((cj4*new_r01))+((new_r11*sj4)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=((((-1.0)*(1.0)*cj4))+new_r02);
evalcond[3]=((((-1.0)*x287))+new_r12);
evalcond[4]=x288;
evalcond[5]=x288;
evalcond[6]=x289;
evalcond[7]=x290;
evalcond[8]=x291;
evalcond[9]=x290;
evalcond[10]=x291;
evalcond[11]=x289;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*(((1.0)*new_r21)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*(((1.0)*new_r21))))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*(((1.0)*new_r21))), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x292=IKsin(j6);
IkReal x293=IKcos(j6);
IkReal x294=((1.0)*new_r12);
evalcond[0]=(x292+new_r21);
evalcond[1]=((((-1.0)*x293))+new_r20);
evalcond[2]=(((new_r02*x292))+new_r10);
evalcond[3]=(((new_r02*x293))+new_r11);
evalcond[4]=((((-1.0)*x292*x294))+new_r00);
evalcond[5]=((((-1.0)*x293*x294))+new_r01);
evalcond[6]=(x292+(((-1.0)*new_r00*x294))+((new_r02*new_r10)));
evalcond[7]=(x293+((new_r02*new_r11))+(((-1.0)*new_r01*x294)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x295=((((-1.0)*(1.0)*new_r02*sj4))+((cj4*new_r12)));
IkReal x296=(cj4*new_r02);
IkReal x297=(new_r12*sj4);
IkReal x298=(cj4*new_r00);
IkReal x299=(new_r10*sj4);
IkReal x300=(cj4*new_r01);
IkReal x301=(new_r11*sj4);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=(cj4+new_r02);
evalcond[3]=(sj4+new_r12);
evalcond[4]=x295;
evalcond[5]=x295;
evalcond[6]=((1.0)+x297+x296);
evalcond[7]=(x299+x298);
evalcond[8]=(x301+x300);
evalcond[9]=((((-1.0)*x299))+(((-1.0)*x298)));
evalcond[10]=((((-1.0)*x301))+(((-1.0)*x300)));
evalcond[11]=((-1.0)+(((-1.0)*x296))+(((-1.0)*x297)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*(((1.0)*new_r20)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*(((1.0)*new_r20))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*(((1.0)*new_r20))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x302=IKcos(j6);
IkReal x303=IKsin(j6);
IkReal x304=((1.0)*new_r02);
evalcond[0]=(x302+new_r20);
evalcond[1]=((((-1.0)*x303))+new_r21);
evalcond[2]=(((new_r12*x303))+new_r00);
evalcond[3]=(new_r01+((new_r12*x302)));
evalcond[4]=((((-1.0)*x303*x304))+new_r10);
evalcond[5]=((((-1.0)*x302*x304))+new_r11);
evalcond[6]=(x303+((new_r00*new_r12))+(((-1.0)*new_r10*x304)));
evalcond[7]=(x302+((new_r01*new_r12))+(((-1.0)*new_r11*x304)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x305=((1.0)*cj5);
IkReal x306=((((-1.0)*x305))+new_r22);
IkReal x307=(new_r02+(((-1.0)*(1.0)*sj5)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=x306;
evalcond[2]=x306;
evalcond[3]=x307;
evalcond[4]=new_r12;
evalcond[5]=x307;
evalcond[6]=(((cj5*new_r20))+((new_r00*sj5)));
evalcond[7]=(((new_r01*sj5))+((cj5*new_r21)));
evalcond[8]=((-1.0)+((new_r02*sj5))+((cj5*new_r22)));
evalcond[9]=(((new_r22*sj5))+(((-1.0)*new_r02*x305)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*(((1.0)*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*(((1.0)*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*(((1.0)*new_r10))))+IKsqr(((-1.0)*(((1.0)*new_r11))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*(((1.0)*new_r10))), ((-1.0)*(((1.0)*new_r11))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x308=IKsin(j6);
IkReal x309=IKcos(j6);
IkReal x310=((1.0)*x309);
IkReal x311=((1.0)*new_r22);
evalcond[0]=(x308+new_r10);
evalcond[1]=(x309+new_r11);
evalcond[2]=(((new_r02*x308))+new_r21);
evalcond[3]=(((new_r22*x309))+new_r00);
evalcond[4]=((((-1.0)*new_r02*x310))+new_r20);
evalcond[5]=((((-1.0)*x308*x311))+new_r01);
evalcond[6]=(((new_r02*new_r21))+x308+(((-1.0)*new_r01*x311)));
evalcond[7]=((((-1.0)*x310))+((new_r02*new_r20))+(((-1.0)*new_r00*x311)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x312=((((-1.0)*(1.0)*cj5))+new_r22);
IkReal x313=((1.0)*new_r02);
IkReal x314=((1.0)*sj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=x312;
evalcond[2]=x312;
evalcond[3]=(sj5+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((((-1.0)*x313))+(((-1.0)*x314)));
evalcond[6]=((((-1.0)*new_r00*x314))+((cj5*new_r20)));
evalcond[7]=((((-1.0)*new_r01*x314))+((cj5*new_r21)));
evalcond[8]=((-1.0)+(((-1.0)*sj5*x313))+((cj5*new_r22)));
evalcond[9]=(((new_r22*sj5))+((cj5*new_r02)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r10, new_r11);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x315=IKcos(j6);
IkReal x316=IKsin(j6);
IkReal x317=((1.0)*new_r02);
evalcond[0]=(((new_r02*x315))+new_r20);
evalcond[1]=((((-1.0)*(1.0)*new_r10))+x316);
evalcond[2]=(x315+(((-1.0)*(1.0)*new_r11)));
evalcond[3]=((((-1.0)*x316*x317))+new_r21);
evalcond[4]=((((-1.0)*(1.0)*new_r00))+((new_r22*x315)));
evalcond[5]=((((-1.0)*(1.0)*new_r01))+(((-1.0)*new_r22*x316)));
evalcond[6]=((((-1.0)*new_r21*x317))+((new_r01*new_r22))+x316);
evalcond[7]=((((-1.0)*new_r20*x317))+((new_r00*new_r22))+(((-1.0)*x315)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x318=((1.0)*cj5);
IkReal x319=((((-1.0)*x318))+new_r22);
IkReal x320=(new_r12+(((-1.0)*(1.0)*sj5)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=x319;
evalcond[2]=x319;
evalcond[3]=new_r02;
evalcond[4]=x320;
evalcond[5]=x320;
evalcond[6]=(((new_r10*sj5))+((cj5*new_r20)));
evalcond[7]=(((new_r11*sj5))+((cj5*new_r21)));
evalcond[8]=((-1.0)+((new_r12*sj5))+((cj5*new_r22)));
evalcond[9]=(((new_r22*sj5))+(((-1.0)*new_r12*x318)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r00, new_r01);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x321=IKsin(j6);
IkReal x322=IKcos(j6);
IkReal x323=((1.0)*x322);
IkReal x324=((1.0)*new_r22);
evalcond[0]=(((new_r12*x321))+new_r21);
evalcond[1]=(x321+(((-1.0)*(1.0)*new_r00)));
evalcond[2]=(x322+(((-1.0)*(1.0)*new_r01)));
evalcond[3]=(new_r10+((new_r22*x322)));
evalcond[4]=((((-1.0)*new_r12*x323))+new_r20);
evalcond[5]=((((-1.0)*x321*x324))+new_r11);
evalcond[6]=(((new_r12*new_r21))+(((-1.0)*new_r11*x324))+x321);
evalcond[7]=((((-1.0)*x323))+((new_r12*new_r20))+(((-1.0)*new_r10*x324)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x325=((((-1.0)*(1.0)*cj5))+new_r22);
IkReal x326=((1.0)*new_r12);
IkReal x327=((1.0)*sj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=x325;
evalcond[2]=x325;
evalcond[3]=new_r02;
evalcond[4]=(sj5+new_r12);
evalcond[5]=((((-1.0)*x326))+(((-1.0)*x327)));
evalcond[6]=(((cj5*new_r20))+(((-1.0)*new_r10*x327)));
evalcond[7]=((((-1.0)*new_r11*x327))+((cj5*new_r21)));
evalcond[8]=((-1.0)+(((-1.0)*sj5*x326))+((cj5*new_r22)));
evalcond[9]=(((new_r22*sj5))+((cj5*new_r12)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*(((1.0)*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*(((1.0)*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*(((1.0)*new_r00))))+IKsqr(((-1.0)*(((1.0)*new_r01))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*(((1.0)*new_r00))), ((-1.0)*(((1.0)*new_r01))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x328=IKsin(j6);
IkReal x329=IKcos(j6);
IkReal x330=((1.0)*new_r12);
evalcond[0]=(x328+new_r00);
evalcond[1]=(x329+new_r01);
evalcond[2]=(((new_r12*x329))+new_r20);
evalcond[3]=((((-1.0)*x328*x330))+new_r21);
evalcond[4]=((((-1.0)*(1.0)*new_r10))+((new_r22*x329)));
evalcond[5]=((((-1.0)*new_r22*x328))+(((-1.0)*(1.0)*new_r11)));
evalcond[6]=(((new_r11*new_r22))+(((-1.0)*new_r21*x330))+x328);
evalcond[7]=(((new_r10*new_r22))+(((-1.0)*x329))+(((-1.0)*new_r20*x330)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x332=IKPowWithIntegerCheck(sj5,-1);
if(!x332.valid){
continue;
}
IkReal x331=x332.value;
CheckValue<IkReal> x333=IKPowWithIntegerCheck(cj5,-1);
if(!x333.valid){
continue;
}
CheckValue<IkReal> x334=IKPowWithIntegerCheck(sj4,-1);
if(!x334.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*x331)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x331*(x333.value)*(x334.value)*((((cj4*new_r21))+(((-1.0)*(1.0)*new_r10*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x331))+IKsqr((x331*(x333.value)*(x334.value)*((((cj4*new_r21))+(((-1.0)*(1.0)*new_r10*sj5))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21*x331), (x331*(x333.value)*(x334.value)*((((cj4*new_r21))+(((-1.0)*(1.0)*new_r10*sj5))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x335=IKsin(j6);
IkReal x336=IKcos(j6);
IkReal x337=((1.0)*x336);
IkReal x338=((1.0)*sj4);
IkReal x339=(cj4*new_r00);
IkReal x340=(new_r10*sj4);
IkReal x341=(cj5*x336);
IkReal x342=(cj4*x335);
IkReal x343=(cj4*new_r01);
IkReal x344=(new_r11*sj4);
IkReal x345=((1.0)*cj5);
IkReal x346=(x335*x338);
IkReal x347=(cj4*x336);
evalcond[0]=(((sj5*x335))+new_r21);
evalcond[1]=((((-1.0)*sj5*x337))+new_r20);
evalcond[2]=(((cj4*new_r10))+(((-1.0)*new_r00*x338))+x335);
evalcond[3]=(x336+((cj4*new_r11))+(((-1.0)*new_r01*x338)));
evalcond[4]=(x339+x340+x341);
evalcond[5]=(((sj4*x341))+new_r10+x342);
evalcond[6]=((((-1.0)*x335*x345))+x344+x343);
evalcond[7]=((((-1.0)*x346))+((cj5*x347))+new_r00);
evalcond[8]=((((-1.0)*cj5*x346))+new_r11+x347);
evalcond[9]=((((-1.0)*x336*x338))+new_r01+(((-1.0)*x342*x345)));
evalcond[10]=((((-1.0)*x344*x345))+(((-1.0)*x343*x345))+x335+((new_r21*sj5)));
evalcond[11]=((((-1.0)*x337))+((new_r20*sj5))+(((-1.0)*x339*x345))+(((-1.0)*x340*x345)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x348=((1.0)*new_r21);
CheckValue<IkReal> x350=IKPowWithIntegerCheck(sj5,-1);
if(!x350.valid){
continue;
}
IkReal x349=x350.value;
CheckValue<IkReal> x351=IKPowWithIntegerCheck(cj4,-1);
if(!x351.valid){
continue;
}
if( IKabs(((-1.0)*x348*x349)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x349*(x351.value)*(((((-1.0)*cj5*sj4*x348))+(((-1.0)*(1.0)*new_r11*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*x348*x349))+IKsqr((x349*(x351.value)*(((((-1.0)*cj5*sj4*x348))+(((-1.0)*(1.0)*new_r11*sj5))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*x348*x349), (x349*(x351.value)*(((((-1.0)*cj5*sj4*x348))+(((-1.0)*(1.0)*new_r11*sj5))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x352=IKsin(j6);
IkReal x353=IKcos(j6);
IkReal x354=((1.0)*x353);
IkReal x355=((1.0)*sj4);
IkReal x356=(cj4*new_r00);
IkReal x357=(new_r10*sj4);
IkReal x358=(cj5*x353);
IkReal x359=(cj4*x352);
IkReal x360=(cj4*new_r01);
IkReal x361=(new_r11*sj4);
IkReal x362=((1.0)*cj5);
IkReal x363=(x352*x355);
IkReal x364=(cj4*x353);
evalcond[0]=(((sj5*x352))+new_r21);
evalcond[1]=((((-1.0)*sj5*x354))+new_r20);
evalcond[2]=(((cj4*new_r10))+x352+(((-1.0)*new_r00*x355)));
evalcond[3]=(x353+(((-1.0)*new_r01*x355))+((cj4*new_r11)));
evalcond[4]=(x358+x357+x356);
evalcond[5]=(x359+((sj4*x358))+new_r10);
evalcond[6]=((((-1.0)*x352*x362))+x360+x361);
evalcond[7]=((((-1.0)*x363))+((cj5*x364))+new_r00);
evalcond[8]=((((-1.0)*cj5*x363))+x364+new_r11);
evalcond[9]=((((-1.0)*x359*x362))+(((-1.0)*x353*x355))+new_r01);
evalcond[10]=(x352+(((-1.0)*x360*x362))+((new_r21*sj5))+(((-1.0)*x361*x362)));
evalcond[11]=(((new_r20*sj5))+(((-1.0)*x354))+(((-1.0)*x356*x362))+(((-1.0)*x357*x362)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x365 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*new_r21)))),new_r20,IKFAST_ATAN2_MAGTHRESH);
if(!x365.valid){
continue;
}
CheckValue<IkReal> x366=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x366.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x365.value)+(((1.5707963267949)*(x366.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x367=IKsin(j6);
IkReal x368=IKcos(j6);
IkReal x369=((1.0)*x368);
IkReal x370=((1.0)*sj4);
IkReal x371=(cj4*new_r00);
IkReal x372=(new_r10*sj4);
IkReal x373=(cj5*x368);
IkReal x374=(cj4*x367);
IkReal x375=(cj4*new_r01);
IkReal x376=(new_r11*sj4);
IkReal x377=((1.0)*cj5);
IkReal x378=(x367*x370);
IkReal x379=(cj4*x368);
evalcond[0]=(((sj5*x367))+new_r21);
evalcond[1]=((((-1.0)*sj5*x369))+new_r20);
evalcond[2]=(((cj4*new_r10))+(((-1.0)*new_r00*x370))+x367);
evalcond[3]=(x368+((cj4*new_r11))+(((-1.0)*new_r01*x370)));
evalcond[4]=(x371+x372+x373);
evalcond[5]=(((sj4*x373))+new_r10+x374);
evalcond[6]=((((-1.0)*x367*x377))+x376+x375);
evalcond[7]=(((cj5*x379))+(((-1.0)*x378))+new_r00);
evalcond[8]=((((-1.0)*cj5*x378))+new_r11+x379);
evalcond[9]=(new_r01+(((-1.0)*x374*x377))+(((-1.0)*x368*x370)));
evalcond[10]=(((new_r21*sj5))+x367+(((-1.0)*x376*x377))+(((-1.0)*x375*x377)));
evalcond[11]=((((-1.0)*x372*x377))+((new_r20*sj5))+(((-1.0)*x369))+(((-1.0)*x371*x377)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x380 = IKatan2WithCheck(IkReal(new_r12),new_r02,IKFAST_ATAN2_MAGTHRESH);
if(!x380.valid){
continue;
}
CheckValue<IkReal> x381=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x381.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x380.value)+(((1.5707963267949)*(x381.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break;
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x382=IKcos(j4);
IkReal x383=((1.0)*sj5);
IkReal x384=IKsin(j4);
IkReal x385=(new_r02*x382);
IkReal x386=(new_r12*x384);
IkReal x387=(sj5*x382);
IkReal x388=(sj5*x384);
IkReal x389=((1.0)*cj5);
evalcond[0]=((((-1.0)*x382*x383))+new_r02);
evalcond[1]=((((-1.0)*x383*x384))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x384))+((new_r12*x382)));
evalcond[3]=((((-1.0)*x383))+x386+x385);
evalcond[4]=(((new_r10*x388))+((new_r00*x387))+((cj5*new_r20)));
evalcond[5]=(((new_r11*x388))+((cj5*new_r21))+((new_r01*x387)));
evalcond[6]=((-1.0)+((sj5*x385))+((cj5*new_r22))+((sj5*x386)));
evalcond[7]=(((new_r22*sj5))+(((-1.0)*x385*x389))+(((-1.0)*x386*x389)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6eval[2];
IkReal x390=(cj1*sj3);
IkReal x391=((1.0)*cj2);
IkReal x392=(cj3*sj1);
IkReal x393=(x390+(((-1.0)*x391*x392)));
IkReal x394=(sj1*sj3);
IkReal x395=(cj1*cj3);
IkReal x396=(x394+((cj2*x395)));
IkReal x397=(((sj0*x396))+((cj3*((cj0*sj2)))));
IkReal x398=((1.0)*sj0*sj2);
IkReal x399=(((cj0*x396))+(((-1.0)*cj3*x398)));
IkReal x400=(sj1*sj2);
IkReal x401=x146;
IkReal x402=((1.0)*cj0*sj2);
IkReal x403=x148;
IkReal x404=(x395+((cj2*x394)));
IkReal x405=(x392+(((-1.0)*x390*x391)));
IkReal x406=(((cj0*x405))+((sj3*((sj0*sj2)))));
IkReal x407=(((sj0*x405))+(((-1.0)*sj3*x402)));
new_r00=(((r10*x397))+((r20*x393))+((r00*x399)));
new_r01=(((r11*x397))+((r21*x393))+((r01*x399)));
new_r02=(((r02*x399))+((r22*x393))+((r12*x397)));
new_r10=(((r10*x401))+((r20*x400))+((r00*x403)));
new_r11=(((r11*x401))+((r21*x400))+((r01*x403)));
new_r12=(((r02*x403))+((r22*x400))+((r12*x401)));
new_r20=(((r10*x407))+((r00*x406))+((r20*x404)));
new_r21=(((r21*x404))+((r11*x407))+((r01*x406)));
new_r22=(((r02*x406))+((r12*x407))+((r22*x404)));
j6eval[0]=sj5;
j6eval[1]=IKsign(sj5);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
IkReal x408=(cj1*sj3);
IkReal x409=((1.0)*cj2);
IkReal x410=(cj3*sj1);
IkReal x411=((((-1.0)*x409*x410))+x408);
IkReal x412=(sj1*sj3);
IkReal x413=(cj1*cj3);
IkReal x414=(x412+((cj2*x413)));
IkReal x415=(((sj0*x414))+((cj3*((cj0*sj2)))));
IkReal x416=((1.0)*sj0*sj2);
IkReal x417=((((-1.0)*cj3*x416))+((cj0*x414)));
IkReal x418=(sj1*sj2);
IkReal x419=x146;
IkReal x420=((1.0)*cj0*sj2);
IkReal x421=x148;
IkReal x422=(x413+((cj2*x412)));
IkReal x423=(x410+(((-1.0)*x408*x409)));
IkReal x424=(((cj0*x423))+((sj3*((sj0*sj2)))));
IkReal x425=((((-1.0)*sj3*x420))+((sj0*x423)));
new_r00=(((r20*x411))+((r00*x417))+((r10*x415)));
new_r01=(((r11*x415))+((r21*x411))+((r01*x417)));
new_r02=(((r12*x415))+((r22*x411))+((r02*x417)));
new_r10=(((r10*x419))+((r00*x421))+((r20*x418)));
new_r11=(((r01*x421))+((r21*x418))+((r11*x419)));
new_r12=(((r12*x419))+((r22*x418))+((r02*x421)));
new_r20=(((r20*x422))+((r10*x425))+((r00*x424)));
new_r21=(((r01*x424))+((r11*x425))+((r21*x422)));
new_r22=(((r22*x422))+((r12*x425))+((r02*x424)));
j6eval[0]=sj5;
j6eval[1]=cj4;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
IkReal x426=(cj1*sj3);
IkReal x427=((1.0)*cj2);
IkReal x428=(cj3*sj1);
IkReal x429=(x426+(((-1.0)*x427*x428)));
IkReal x430=(sj1*sj3);
IkReal x431=(cj1*cj3);
IkReal x432=(((cj2*x431))+x430);
IkReal x433=(((cj3*((cj0*sj2))))+((sj0*x432)));
IkReal x434=((1.0)*sj0*sj2);
IkReal x435=((((-1.0)*cj3*x434))+((cj0*x432)));
IkReal x436=(sj1*sj2);
IkReal x437=x146;
IkReal x438=((1.0)*cj0*sj2);
IkReal x439=x148;
IkReal x440=(((cj2*x430))+x431);
IkReal x441=(x428+(((-1.0)*x426*x427)));
IkReal x442=(((cj0*x441))+((sj3*((sj0*sj2)))));
IkReal x443=((((-1.0)*sj3*x438))+((sj0*x441)));
new_r00=(((r00*x435))+((r10*x433))+((r20*x429)));
new_r01=(((r01*x435))+((r21*x429))+((r11*x433)));
new_r02=(((r12*x433))+((r22*x429))+((r02*x435)));
new_r10=(((r20*x436))+((r00*x439))+((r10*x437)));
new_r11=(((r01*x439))+((r21*x436))+((r11*x437)));
new_r12=(((r22*x436))+((r02*x439))+((r12*x437)));
new_r20=(((r00*x442))+((r10*x443))+((r20*x440)));
new_r21=(((r01*x442))+((r21*x440))+((r11*x443)));
new_r22=(((r02*x442))+((r22*x440))+((r12*x443)));
j6eval[0]=sj5;
j6eval[1]=cj5;
j6eval[2]=sj4;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x444=((((-1.0)*(1.0)*new_r02*sj4))+((cj4*new_r12)));
IkReal x445=(cj4*new_r02);
IkReal x446=(new_r12*sj4);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r21;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r20;
evalcond[6]=x444;
evalcond[7]=x444;
evalcond[8]=(x446+x445);
evalcond[9]=((((-1.0)*x446))+(((-1.0)*x445)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x447=((1.0)*cj4);
if( IKabs(((((-1.0)*new_r10*x447))+((new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r00*x447))+(((-1.0)*(1.0)*new_r10*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r10*x447))+((new_r00*sj4))))+IKsqr(((((-1.0)*new_r00*x447))+(((-1.0)*(1.0)*new_r10*sj4))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*new_r10*x447))+((new_r00*sj4))), ((((-1.0)*new_r00*x447))+(((-1.0)*(1.0)*new_r10*sj4))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x448=IKcos(j6);
IkReal x449=IKsin(j6);
IkReal x450=((1.0)*sj4);
IkReal x451=(cj4*x449);
IkReal x452=(((cj4*x448))+(((-1.0)*x449*x450)));
evalcond[0]=(((cj4*new_r00))+((new_r10*sj4))+x448);
evalcond[1]=(((cj4*new_r10))+(((-1.0)*new_r00*x450))+x449);
evalcond[2]=((((-1.0)*new_r01*x450))+x448+((cj4*new_r11)));
evalcond[3]=(((sj4*x448))+x451+new_r10);
evalcond[4]=(((cj4*new_r01))+((new_r11*sj4))+(((-1.0)*x449)));
evalcond[5]=(x452+new_r00);
evalcond[6]=(x452+new_r11);
evalcond[7]=((((-1.0)*x451))+(((-1.0)*x448*x450))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x453=((((-1.0)*(1.0)*new_r02*sj4))+((cj4*new_r12)));
IkReal x454=(((cj4*new_r02))+((new_r12*sj4)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r21;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r20;
evalcond[6]=x453;
evalcond[7]=x453;
evalcond[8]=x454;
evalcond[9]=x454;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x455=((1.0)*cj4);
if( IKabs(((((-1.0)*(1.0)*new_r11*sj4))+(((-1.0)*new_r10*x455)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r11*x455))+((new_r10*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*(1.0)*new_r11*sj4))+(((-1.0)*new_r10*x455))))+IKsqr(((((-1.0)*new_r11*x455))+((new_r10*sj4))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*(1.0)*new_r11*sj4))+(((-1.0)*new_r10*x455))), ((((-1.0)*new_r11*x455))+((new_r10*sj4))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x456=IKsin(j6);
IkReal x457=((1.0)*sj4);
IkReal x458=IKcos(j6);
IkReal x459=(cj4*x458);
IkReal x460=(((cj4*x456))+(((-1.0)*x457*x458)));
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x456);
evalcond[1]=(((cj4*new_r10))+(((-1.0)*new_r00*x457))+x456);
evalcond[2]=(x458+((cj4*new_r11))+(((-1.0)*new_r01*x457)));
evalcond[3]=((((-1.0)*x458))+((cj4*new_r00))+((new_r10*sj4)));
evalcond[4]=(((sj4*x456))+x459+new_r11);
evalcond[5]=(new_r10+x460);
evalcond[6]=(new_r01+x460);
evalcond[7]=((((-1.0)*x459))+(((-1.0)*x456*x457))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x461=((1.0)*sj4);
IkReal x462=(((cj4*new_r12))+(((-1.0)*new_r02*x461)));
IkReal x463=((-1.0)+((cj4*new_r02))+((new_r12*sj4)));
IkReal x464=(((cj4*new_r00))+((new_r10*sj4)));
IkReal x465=(((cj4*new_r01))+((new_r11*sj4)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=((((-1.0)*(1.0)*cj4))+new_r02);
evalcond[3]=((((-1.0)*x461))+new_r12);
evalcond[4]=x462;
evalcond[5]=x462;
evalcond[6]=x463;
evalcond[7]=x464;
evalcond[8]=x465;
evalcond[9]=x464;
evalcond[10]=x465;
evalcond[11]=x463;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*(((1.0)*new_r21)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*(((1.0)*new_r21))))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*(((1.0)*new_r21))), new_r20);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x466=IKsin(j6);
IkReal x467=IKcos(j6);
IkReal x468=((1.0)*new_r12);
evalcond[0]=(new_r21+x466);
evalcond[1]=((((-1.0)*x467))+new_r20);
evalcond[2]=(new_r10+((new_r02*x466)));
evalcond[3]=(new_r11+((new_r02*x467)));
evalcond[4]=((((-1.0)*x466*x468))+new_r00);
evalcond[5]=((((-1.0)*x467*x468))+new_r01);
evalcond[6]=((((-1.0)*new_r00*x468))+((new_r02*new_r10))+x466);
evalcond[7]=((((-1.0)*new_r01*x468))+((new_r02*new_r11))+x467);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x469=((((-1.0)*(1.0)*new_r02*sj4))+((cj4*new_r12)));
IkReal x470=(cj4*new_r02);
IkReal x471=(new_r12*sj4);
IkReal x472=(cj4*new_r00);
IkReal x473=(new_r10*sj4);
IkReal x474=(cj4*new_r01);
IkReal x475=(new_r11*sj4);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=(cj4+new_r02);
evalcond[3]=(sj4+new_r12);
evalcond[4]=x469;
evalcond[5]=x469;
evalcond[6]=((1.0)+x470+x471);
evalcond[7]=(x472+x473);
evalcond[8]=(x474+x475);
evalcond[9]=((((-1.0)*x473))+(((-1.0)*x472)));
evalcond[10]=((((-1.0)*x474))+(((-1.0)*x475)));
evalcond[11]=((-1.0)+(((-1.0)*x470))+(((-1.0)*x471)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*(((1.0)*new_r20)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*(((1.0)*new_r20))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r21, ((-1.0)*(((1.0)*new_r20))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x476=IKcos(j6);
IkReal x477=IKsin(j6);
IkReal x478=((1.0)*new_r02);
evalcond[0]=(x476+new_r20);
evalcond[1]=((((-1.0)*x477))+new_r21);
evalcond[2]=(((new_r12*x477))+new_r00);
evalcond[3]=(((new_r12*x476))+new_r01);
evalcond[4]=((((-1.0)*x477*x478))+new_r10);
evalcond[5]=((((-1.0)*x476*x478))+new_r11);
evalcond[6]=(x477+((new_r00*new_r12))+(((-1.0)*new_r10*x478)));
evalcond[7]=(x476+((new_r01*new_r12))+(((-1.0)*new_r11*x478)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x479=((1.0)*cj5);
IkReal x480=((((-1.0)*x479))+new_r22);
IkReal x481=(new_r02+(((-1.0)*(1.0)*sj5)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=x480;
evalcond[2]=x480;
evalcond[3]=x481;
evalcond[4]=new_r12;
evalcond[5]=x481;
evalcond[6]=(((cj5*new_r20))+((new_r00*sj5)));
evalcond[7]=(((new_r01*sj5))+((cj5*new_r21)));
evalcond[8]=((-1.0)+((new_r02*sj5))+((cj5*new_r22)));
evalcond[9]=(((new_r22*sj5))+(((-1.0)*new_r02*x479)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*(((1.0)*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*(((1.0)*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*(((1.0)*new_r10))))+IKsqr(((-1.0)*(((1.0)*new_r11))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*(((1.0)*new_r10))), ((-1.0)*(((1.0)*new_r11))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x482=IKsin(j6);
IkReal x483=IKcos(j6);
IkReal x484=((1.0)*x483);
IkReal x485=((1.0)*new_r22);
evalcond[0]=(new_r10+x482);
evalcond[1]=(new_r11+x483);
evalcond[2]=(((new_r02*x482))+new_r21);
evalcond[3]=(((new_r22*x483))+new_r00);
evalcond[4]=((((-1.0)*new_r02*x484))+new_r20);
evalcond[5]=((((-1.0)*x482*x485))+new_r01);
evalcond[6]=(((new_r02*new_r21))+(((-1.0)*new_r01*x485))+x482);
evalcond[7]=(((new_r02*new_r20))+(((-1.0)*new_r00*x485))+(((-1.0)*x484)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x486=((((-1.0)*(1.0)*cj5))+new_r22);
IkReal x487=((1.0)*new_r02);
IkReal x488=((1.0)*sj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=x486;
evalcond[2]=x486;
evalcond[3]=(sj5+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((((-1.0)*x488))+(((-1.0)*x487)));
evalcond[6]=((((-1.0)*new_r00*x488))+((cj5*new_r20)));
evalcond[7]=(((cj5*new_r21))+(((-1.0)*new_r01*x488)));
evalcond[8]=((-1.0)+(((-1.0)*sj5*x487))+((cj5*new_r22)));
evalcond[9]=(((new_r22*sj5))+((cj5*new_r02)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r10, new_r11);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x489=IKcos(j6);
IkReal x490=IKsin(j6);
IkReal x491=((1.0)*new_r02);
evalcond[0]=(((new_r02*x489))+new_r20);
evalcond[1]=((((-1.0)*(1.0)*new_r10))+x490);
evalcond[2]=((((-1.0)*(1.0)*new_r11))+x489);
evalcond[3]=((((-1.0)*x490*x491))+new_r21);
evalcond[4]=(((new_r22*x489))+(((-1.0)*(1.0)*new_r00)));
evalcond[5]=((((-1.0)*new_r22*x490))+(((-1.0)*(1.0)*new_r01)));
evalcond[6]=(((new_r01*new_r22))+(((-1.0)*new_r21*x491))+x490);
evalcond[7]=((((-1.0)*new_r20*x491))+(((-1.0)*x489))+((new_r00*new_r22)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x492=((1.0)*cj5);
IkReal x493=((((-1.0)*x492))+new_r22);
IkReal x494=(new_r12+(((-1.0)*(1.0)*sj5)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=x493;
evalcond[2]=x493;
evalcond[3]=new_r02;
evalcond[4]=x494;
evalcond[5]=x494;
evalcond[6]=(((new_r10*sj5))+((cj5*new_r20)));
evalcond[7]=(((new_r11*sj5))+((cj5*new_r21)));
evalcond[8]=((-1.0)+((new_r12*sj5))+((cj5*new_r22)));
evalcond[9]=(((new_r22*sj5))+(((-1.0)*new_r12*x492)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r00, new_r01);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x495=IKsin(j6);
IkReal x496=IKcos(j6);
IkReal x497=((1.0)*x496);
IkReal x498=((1.0)*new_r22);
evalcond[0]=(((new_r12*x495))+new_r21);
evalcond[1]=((((-1.0)*(1.0)*new_r00))+x495);
evalcond[2]=((((-1.0)*(1.0)*new_r01))+x496);
evalcond[3]=(((new_r22*x496))+new_r10);
evalcond[4]=((((-1.0)*new_r12*x497))+new_r20);
evalcond[5]=(new_r11+(((-1.0)*x495*x498)));
evalcond[6]=((((-1.0)*new_r11*x498))+((new_r12*new_r21))+x495);
evalcond[7]=((((-1.0)*x497))+(((-1.0)*new_r10*x498))+((new_r12*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x499=((((-1.0)*(1.0)*cj5))+new_r22);
IkReal x500=((1.0)*new_r12);
IkReal x501=((1.0)*sj5);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=x499;
evalcond[2]=x499;
evalcond[3]=new_r02;
evalcond[4]=(sj5+new_r12);
evalcond[5]=((((-1.0)*x500))+(((-1.0)*x501)));
evalcond[6]=(((cj5*new_r20))+(((-1.0)*new_r10*x501)));
evalcond[7]=(((cj5*new_r21))+(((-1.0)*new_r11*x501)));
evalcond[8]=((-1.0)+(((-1.0)*sj5*x500))+((cj5*new_r22)));
evalcond[9]=(((new_r22*sj5))+((cj5*new_r12)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*(((1.0)*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*(((1.0)*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*(((1.0)*new_r00))))+IKsqr(((-1.0)*(((1.0)*new_r01))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*(((1.0)*new_r00))), ((-1.0)*(((1.0)*new_r01))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x502=IKsin(j6);
IkReal x503=IKcos(j6);
IkReal x504=((1.0)*new_r12);
evalcond[0]=(x502+new_r00);
evalcond[1]=(x503+new_r01);
evalcond[2]=(((new_r12*x503))+new_r20);
evalcond[3]=((((-1.0)*x502*x504))+new_r21);
evalcond[4]=((((-1.0)*(1.0)*new_r10))+((new_r22*x503)));
evalcond[5]=((((-1.0)*new_r22*x502))+(((-1.0)*(1.0)*new_r11)));
evalcond[6]=((((-1.0)*new_r21*x504))+((new_r11*new_r22))+x502);
evalcond[7]=(((new_r10*new_r22))+(((-1.0)*new_r20*x504))+(((-1.0)*x503)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x506=IKPowWithIntegerCheck(sj5,-1);
if(!x506.valid){
continue;
}
IkReal x505=x506.value;
CheckValue<IkReal> x507=IKPowWithIntegerCheck(cj5,-1);
if(!x507.valid){
continue;
}
CheckValue<IkReal> x508=IKPowWithIntegerCheck(sj4,-1);
if(!x508.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*x505)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x505*(x507.value)*(x508.value)*((((cj4*new_r21))+(((-1.0)*(1.0)*new_r10*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*x505))+IKsqr((x505*(x507.value)*(x508.value)*((((cj4*new_r21))+(((-1.0)*(1.0)*new_r10*sj5))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r21*x505), (x505*(x507.value)*(x508.value)*((((cj4*new_r21))+(((-1.0)*(1.0)*new_r10*sj5))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x509=IKsin(j6);
IkReal x510=IKcos(j6);
IkReal x511=((1.0)*x510);
IkReal x512=((1.0)*sj4);
IkReal x513=(cj4*new_r00);
IkReal x514=(new_r10*sj4);
IkReal x515=(cj5*x510);
IkReal x516=(cj4*x509);
IkReal x517=(cj4*new_r01);
IkReal x518=(new_r11*sj4);
IkReal x519=((1.0)*cj5);
IkReal x520=(x509*x512);
IkReal x521=(cj4*x510);
evalcond[0]=(((sj5*x509))+new_r21);
evalcond[1]=((((-1.0)*sj5*x511))+new_r20);
evalcond[2]=(((cj4*new_r10))+x509+(((-1.0)*new_r00*x512)));
evalcond[3]=(((cj4*new_r11))+x510+(((-1.0)*new_r01*x512)));
evalcond[4]=(x514+x513+x515);
evalcond[5]=(((sj4*x515))+new_r10+x516);
evalcond[6]=((((-1.0)*x509*x519))+x517+x518);
evalcond[7]=(((cj5*x521))+(((-1.0)*x520))+new_r00);
evalcond[8]=(new_r11+(((-1.0)*cj5*x520))+x521);
evalcond[9]=((((-1.0)*x516*x519))+new_r01+(((-1.0)*x510*x512)));
evalcond[10]=(x509+(((-1.0)*x518*x519))+((new_r21*sj5))+(((-1.0)*x517*x519)));
evalcond[11]=(((new_r20*sj5))+(((-1.0)*x511))+(((-1.0)*x513*x519))+(((-1.0)*x514*x519)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x522=((1.0)*new_r21);
CheckValue<IkReal> x524=IKPowWithIntegerCheck(sj5,-1);
if(!x524.valid){
continue;
}
IkReal x523=x524.value;
CheckValue<IkReal> x525=IKPowWithIntegerCheck(cj4,-1);
if(!x525.valid){
continue;
}
if( IKabs(((-1.0)*x522*x523)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x523*(x525.value)*(((((-1.0)*(1.0)*new_r11*sj5))+(((-1.0)*cj5*sj4*x522)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*x522*x523))+IKsqr((x523*(x525.value)*(((((-1.0)*(1.0)*new_r11*sj5))+(((-1.0)*cj5*sj4*x522))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*x522*x523), (x523*(x525.value)*(((((-1.0)*(1.0)*new_r11*sj5))+(((-1.0)*cj5*sj4*x522))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x526=IKsin(j6);
IkReal x527=IKcos(j6);
IkReal x528=((1.0)*x527);
IkReal x529=((1.0)*sj4);
IkReal x530=(cj4*new_r00);
IkReal x531=(new_r10*sj4);
IkReal x532=(cj5*x527);
IkReal x533=(cj4*x526);
IkReal x534=(cj4*new_r01);
IkReal x535=(new_r11*sj4);
IkReal x536=((1.0)*cj5);
IkReal x537=(x526*x529);
IkReal x538=(cj4*x527);
evalcond[0]=(((sj5*x526))+new_r21);
evalcond[1]=((((-1.0)*sj5*x528))+new_r20);
evalcond[2]=(((cj4*new_r10))+(((-1.0)*new_r00*x529))+x526);
evalcond[3]=((((-1.0)*new_r01*x529))+((cj4*new_r11))+x527);
evalcond[4]=(x531+x532+x530);
evalcond[5]=(x533+new_r10+((sj4*x532)));
evalcond[6]=(x534+x535+(((-1.0)*x526*x536)));
evalcond[7]=((((-1.0)*x537))+new_r00+((cj5*x538)));
evalcond[8]=(x538+(((-1.0)*cj5*x537))+new_r11);
evalcond[9]=((((-1.0)*x527*x529))+(((-1.0)*x533*x536))+new_r01);
evalcond[10]=((((-1.0)*x534*x536))+((new_r21*sj5))+(((-1.0)*x535*x536))+x526);
evalcond[11]=(((new_r20*sj5))+(((-1.0)*x531*x536))+(((-1.0)*x530*x536))+(((-1.0)*x528)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x539 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*new_r21)))),new_r20,IKFAST_ATAN2_MAGTHRESH);
if(!x539.valid){
continue;
}
CheckValue<IkReal> x540=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x540.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x539.value)+(((1.5707963267949)*(x540.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break;
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x541=IKsin(j6);
IkReal x542=IKcos(j6);
IkReal x543=((1.0)*x542);
IkReal x544=((1.0)*sj4);
IkReal x545=(cj4*new_r00);
IkReal x546=(new_r10*sj4);
IkReal x547=(cj5*x542);
IkReal x548=(cj4*x541);
IkReal x549=(cj4*new_r01);
IkReal x550=(new_r11*sj4);
IkReal x551=((1.0)*cj5);
IkReal x552=(x541*x544);
IkReal x553=(cj4*x542);
evalcond[0]=(((sj5*x541))+new_r21);
evalcond[1]=((((-1.0)*sj5*x543))+new_r20);
evalcond[2]=(((cj4*new_r10))+(((-1.0)*new_r00*x544))+x541);
evalcond[3]=((((-1.0)*new_r01*x544))+((cj4*new_r11))+x542);
evalcond[4]=(x547+x545+x546);
evalcond[5]=(((sj4*x547))+new_r10+x548);
evalcond[6]=((((-1.0)*x541*x551))+x550+x549);
evalcond[7]=(((cj5*x553))+(((-1.0)*x552))+new_r00);
evalcond[8]=(x553+new_r11+(((-1.0)*cj5*x552)));
evalcond[9]=((((-1.0)*x542*x544))+new_r01+(((-1.0)*x548*x551)));
evalcond[10]=((((-1.0)*x550*x551))+((new_r21*sj5))+(((-1.0)*x549*x551))+x541);
evalcond[11]=(((new_r20*sj5))+(((-1.0)*x546*x551))+(((-1.0)*x545*x551))+(((-1.0)*x543)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
(void)pOpenRAVEManip;
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "c9f8911299ac543aff111a5d30b3d40d"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000048"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif

#pragma GCC diagnostic pop
